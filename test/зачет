
### <span style="color:rgb(197, 249, 154)">1. Алгоритмическая сложность. «О большое». Худший\лучший\средний случай</span>

#### <span style="color:rgb(191, 138, 244)">«О большое» определение</span>

Для обозначения класса сложности используется О-нотация. У всякого алгоритма, как у функции есть главная часть, которая занимает больше всего времени для выполнения. Анализируя количество выполнений главной части, делают вывод о поведении алгоритма в зависимости от размера входных данных.

![[Pasted image 20241123135726.png]]

Сложность алгоритма определяет, как долго придется ждать, пока будет получен результат его работы. Всего выделяют 7 классов сложности:

1) О(1) – алгоритмы с постоянным временем выполнения, например доступ к элементу массива. При увеличении размера задачи вдвое время выполнения не меняется, то есть время выполнения не зависит от размера входных данных

2) О(log n) – Алгоритмы с логарифмическим временем выполнения, например, бинарный поиск. Время выполнения удваивается при увеличении размера задачи в n раз. Время выполнения растет логарифмически (медленнее, чем линейно)

3) O(n) – Алгоритмы с линейным временем выполнения, например, последовательный поиск или схема Горнера. При увеличении размера задачи вдвое, время выполнения также удваивается. Время выполнения растет линейно с увеличением размера входных данных

4) O(nlogn) - Алгоритмы с линеарифмическим временем выполнения, например, быстрая сортировка. При увеличении размера вдвое, время выполнения увеличивается немного больше, чем вдвое.

5) O(n^2) - Алгоритмы с квадратичным временем выполнения, например, простые алгоритмы сортировки. При увеличении размера задачи вдвое, время выполнения увеличивается в 4 раза. Время выполнения пропорционально квадрату размера входных данных

6) O(n^3) – Алгоритмы с кубическим временем выполнения, например, умножение матриц. Время выполнения увеличивается в 8 раз при увеличении размера задачи в 2 раза.

7) O(2^n) - Алгоритмы с экспоненциальным временем выполнения, например, задача о составлении расписания. Время выполнения увеличивается в 2 n при увеличении размера задачи в 2 раза.

#### <span style="color:rgb(191, 138, 244)">Худший, лучший и средний случай</span>

Для любого алгоритма важно понимать три типа временной сложности:

1. **Худший случай (Worst-case)**  
    Самое долгое время выполнения алгоритма при самых неблагоприятных входных данных.  
    Пример: в линейном поиске ключ отсутствует в массиве, и алгоритм проверяет все элементы.
    
    - Сложность линейного поиска в худшем случае: O(n).
2. **Лучший случай (Best-case)**  
    Самое быстрое выполнение алгоритма при самых благоприятных входных данных.  
    Пример: в линейном поиске ключ найден на первом элементе.
    
    - Сложность линейного поиска в лучшем случае: O(1).
3. **Средний случай (Average-case)**  
    Среднее время выполнения алгоритма для случайных входных данных.  
    Пример: в линейном поиске ключ находится где-то посередине массива.
    
    - Средняя сложность линейного поиска: O(n/2), что при асимптотическом анализе записывается как O(n).

#### <span style="color:rgb(237, 125, 164)">Примеры из Си</span>

1. **Сортировка пузырьком (Bubble Sort):**
    
    - Худший случай: O(n^2) (массив отсортирован в обратном порядке).
    - Лучший случай: O(n) (массив уже отсортирован).
    - Средний случай: O(n^2).
    - 
2. **Бинарный поиск:**
	- Худший случай: O(log n) (ключ отсутствует или находится в крайнем элементе).
	- Лучший случай: O(1) (ключ найден на первой проверке).
	- Средний случай: O(log n).

#### <span style="color:rgb(237, 125, 164)">Подходы к оценке сложности</span>

1. **Асимптотическое доминирование**  
    Оценивается поведение функции при больших входных данных. Например, в O(n^2 + n) доминирующим является n^2.
    
2. **Игнорирование констант**  
    Например, O(2n) эквивалентно O(n), так как константа 2 не влияет на масштабируемость.

>[!Tip]
>Мы игнорируем константы в нотации **O большое** потому, что она используется для описания **асимптотического поведения** алгоритма, то есть того, как алгоритм ведет себя при очень больших входных данных (n→∞). Константы не влияют на рост функции в таких масштабах, поэтому их можно не учитывать

### <span style="color:rgb(197, 249, 154)">2. Типы данных в языке C. Операции над переменными стандартных типов и их особенности. Операция приведения типов. Арифметические, логические и бинарные операции. Операция быстрого возведения в степень, её алгоритмическая сложность</span>

#### <span style="color:rgb(191, 138, 244)">Типы данных в языке С</span>

В языке C типы данных делятся на несколько категорий:
#### 1. Простые типы (Scalar types):
- **Целочисленные типы (Integer types)**:
    
    - `char` (символы, 1 байт)
    - `int`, `short`, `long`, `long long` (различаются диапазонами значений, зависят от платформы)
    - Указание знаковости: `signed` и `unsigned`.
- **Типы с плавающей запятой (Floating-point types)**:
    
    - `float` (4 байта)
    - `double` (8 байт)
    - `long double` (обычно 10, 12 или 16 байт, в зависимости от от архитектуры процессора (32-битная или 64-битная))

#### 2. Пользовательские типы:
- `struct`, `union`, `enum`

#### 3. Указатели:
- Тип переменной, содержащий адрес в памяти (`int *ptr`).

#### 4. Типы массивов и строк:
- Наборы однотипных элементов: `int arr[10];`, `char str[] = "Hello";`.

#### 5. Специальные типы:
- `void` (отсутствие типа, например, в функциях, которые ничего не возвращают).
#### <span style="color:rgb(191, 138, 244)">Операции над переменными стандартных типов и их особенности</span>

#### Арифметические операции:
- **Сложение, вычитание, умножение, деление, остаток от деления** (`+`, `-`, `*`, `/`, `%`).
- Тип результата зависит от типов операндов:
    - При работе с целыми числами результат будет округлен.
    - В операциях с плавающей запятой используется двойная точность для результата.
- Остаток от деления `%` применим только к целочисленным типам.
#### Логические операции:
- **И, ИЛИ, НЕ**: `&&`, `||`, `!`
- Возвращают `1` (истина) или `0` (ложь).
#### Битовые операции:
- **Побитовые операции**:
    - `&` (AND), `|` (OR), `^` (XOR), `~` (NOT)
- **Сдвиги**:
    - Логический: `<<`, `>>`.
		- Для положительных чисел или **беззнаковых чисел** (`unsigned`) добавляются нули слева при сдвиге вправо, число при этом уменьшается вдвое
    - Арифметический: сохраняет знак.
	    - Используется для **знаковых чисел** (`signed`).
		- Если число отрицательное, старший бит (знаковый) заполняется единицами. Это сохраняет знак числа.
		-  Для положительных чисел арифметический и логический сдвиг вправо дают одинаковый результат.
	    - Для отрицательных чисел логический сдвиг вправо (например, для `unsigned`) заполнит старшие биты нулями, что изменит знак.

```c
unsigned int x = 8;  // 8 = 00001000 в двоичном виде
x = x >> 2;         // Результат: 00000010 (2)
```

```c
int x = -8; // -8 = 11111000 (в двоичной форме для 8-битного знакового числа)
x = x >> 2; // Результат: 11111110 (-2)
```

#### Присваивания:
- `=`, а также укороченные версии (например, `+=`, `*=`).
#### Сравнения:
- `==`, `!=`, `<`, `>`, `<=`, `>=`
Операции сравнения в возвращают результат типа **`int`**, который принимает значение:
- **`1`** (истина), если условие истинно;
- **`0`** (ложь), если условие ложно.
#### <span style="color:rgb(191, 138, 244)">Операция приведения типов</span>

**Приведение типов** (type casting) — это преобразование значения из одного типа данных в другой. Оно бывает **неявным** (implicit) и **явным** (explicit).

#### 1. Неявное приведение типов

Происходит автоматически, когда компилятор преобразует один тип данных в другой. Это может произойти в следующих случаях:

- В выражениях, содержащих операнды разных типов.
- При передаче аргументов в функции.
- При возврате значения из функций.
#### 2. Явное приведение типов

Явное приведение (explicit casting) используется, когда программист самостоятельно указывает, как преобразовать тип. Для этого применяется оператор `(type)` перед выражением.

```c
(type) expression
```

#### Примеры:

1. **Преобразование `float` в `int`:**

```c
float f = 5.99;
int i = (int)f;  // Результат: 5 (дробная часть отбрасывается)
```

2. Преобразование `int` в `float`:

```c
int a = 10;
float b = (float)a / 3;  // Результат: 3.333333
```

3. **Работа с указателями:** указатели одного типа преобразуются в указатели другого:

```c
void *ptr;
int *intPtr = (int *)ptr;  // Явное приведение void* к int*
```

#### <span style="color:rgb(191, 138, 244)">Операция быстрого возведения в степень, её алгоритмическая сложность</span>

- Идея: вычисляем a^b за O(log⁡b), разделяя степень на 2
```c
double power(int a, int b) {
    double res = 1.0;
    int isNegative = b < 0;
    b = abs(b);
    while (b > 0) {
        if (b % 2 == 1) {
            res *= a;
        }
        a *= a;
        b /= 2;
    }
    return isNegative ? 1.0 / res : res;
}
```
- Алгоритмическая сложность: O(log⁡b).
- Степень делится на два на каждом шаге (`b /= 2`), что делает сложность алгоритма O(log⁡b).
- Это намного быстрее, чем наивный алгоритм с O(b).
- По сути разбивает степень на сумму степеней двойки
### <span style="color:rgb(197, 249, 154)">3. Форматы представления целых и вещественных чисел в памяти компьютера</span>

#### <span style="color:rgb(191, 138, 244)">1) Целые числа</span>

Целые числа (типы `int`, `short`, `long`, `char`) хранятся в памяти как набор бит фиксированного размера. Их размер зависит от типа и системы.
#### Знаковое представление (Signed Integers)

Для представления знаковых целых чисел (например, `int`) часто используется **дополнительный код** (Two's Complement). Это позволяет удобно работать с отрицательными числами и нулем.

1. **Дополнительный код (Two's Complement)**:
    
    - Старший бит (слева) обозначает знак: `0` для положительных чисел и `1` для отрицательных.
    - Для отрицательных чисел дополнительный код вычисляется инвертированием всех битов числа и добавлением `1`.
    - Например, для 8-битного представления:
        - +5 — `0000 0101`
        - −5 — инвертируем `0000 0101` до `1111 1010`, добавляем 1: `1111 1011`
        ![[Pasted image 20241022024211.png]]
2. **Прямой код** и **Обратный код** используются редко. Эти методы тоже позволяют представлять отрицательные числа, но не так эффективно, как дополнительный код.
	Причина: 
	В дополнительном коде есть только одно представление для нуля (`0000 0000`), тогда как в других системах (например, в обратном коде) существуют два значения для нуля: положительный и отрицательный (`+0` и `-0`). Наличие двух представлений нуля усложняет операции и требует дополнительных проверок.
#### Беззнаковое представление (Unsigned Integers)

Беззнаковые целые числа (например, `unsigned int`) хранятся как обычные положительные значения, где все биты представляют само число:

```c
00001000  (число 8 для 8-битного unsigned int)
```

### <span style="color:rgb(191, 138, 244)">2) Числа с плавающей точкой</span>

Число с плавающей точкой в памяти компьютера представляется в виде:

![[Pasted image 20241022015610.png]]

- **Sign (знак)** — определяет, положительное число или отрицательное.
- **Mantissa (мантисса)** — это дробная часть числа, хранящая его точность.
- **Exponent (экспонента)** — показатель степени двойки, который сдвигает мантиссу влево или вправо для получения числа нужного порядка величины.
#### Одинарная точность (32 бита)

Одинарная точность числа с плавающей точкой состоит из трёх компонентов:
- **Знак (Sign)**: 1 бит
- **Экспонента (Exponent)**: 8 бит
- **Мантисса (Mantissa или Fraction)**: 23 бита
#### Формат числа
```c
S | EEEEEEEE | FFFFFFFFFFFFFFFFFFFFFFF
```
- **S** — знак числа (1 бит): 0 для положительного числа, 1 для отрицательного.
- **E** — экспонента (8 бит): кодируется с помощью смещённого экспоненциального представления (bias = 127).
- **F** — мантисса (23 бита): нормализованное значение числа.

Для чисел в двоичной системе это означает, что мантисса всегда представляется в виде:
```c
1.F
```
- 1 — скрытая единица, которая **не хранится** в памяти, так как она всегда равна 1.
- F — дробная часть числа, которая хранится в битах мантиссы.
##### Пример:

Представим число 12.375 в двоичном виде:

1. **Преобразование в двоичное представление**: 12.375 = 1100.011 (в двоичной системе).
    
2. **Нормализованная форма**: 1100.011 = 1.100011 * 2^3. То есть, мантисса — это 1.100011, а экспонента — 3.
    
3. **Кодирование в формате IEEE 754 (одинарная точность)**:
    
    - Знак: 0 (положительное число)
    - Экспонента: 3, добавляем смещение 127, получаем 130 = 10000010 (в двоичной системе)
    - Мантисса: 100011 (остальные биты заполняем нулями до 23 бит)

Теперь число 12.375 в 32-битном формате будет:
```c
0 | 10000010 | 10001100000000000000000
```

#### Пример получения нормализованного числа 0.15625

1. **Перевод в двоичное представление**:
    
    0.15625 = 0.00101
2. **Нормализация**:
    
    0.00101 = 1.02 * 2^(-3)
    - Нормализованная мантисса: 1.01
    - Экспонента: −3
3. **Запись**:

    - Мантисса: 01​ (без первой единицы)
    - Экспонента: −3+127=124 (если используется одинарная точность).
#### Почему выбрано смещение 127?

Смещение выбрано таким образом, чтобы половина всех возможных значений экспоненты могла представлять отрицательные значения, а другая половина — положительные. Для 8-битной экспоненты, которая может представлять значения от 0 до 255, при смещении 127:

- Экспонента 0 кодирует значение −127.
- Экспонента 127 кодирует 0.
- Экспонента 255 зарезервирована для специальных значений (например, бесконечность или NaN).

Такое смещение гарантирует, что диапазон возможных значений экспоненты симметрично охватывает как положительные, так и отрицательные значения.

### <span style="color:rgb(197, 249, 154)">4. Условный оператор в языке C. Логические операции и выражения. Тернарный оператор в языке C</span>

#### <span style="color:rgb(191, 138, 244)">Условный оператор в языке C</span>

Условный оператор `if` используется для выполнения блока кода при выполнении определенного условия. Основной синтаксис:

```c
if (условие) {
    // Код, который выполнится, если условие истинно
}
```

Можно добавить блок `else`, который выполнится, если условие ложно:

```c
if (условие) {
    // Код для истинного условия
} else {
    // Код для ложного условия
}
```

Также поддерживается использование нескольких условий с помощью `else if`

```c
if (условие1) {
    // Код для условия1
} else if (условие2) {
    // Код для условия2
} else {
    // Код для всех остальных случаев
}
```

- Если порядок условий неправильно определён, логика программы может нарушиться
- Условия проверяются сверху вниз
- Как только найдено истинное условие, остальные проверки пропускаются
#### <span style="color:rgb(191, 138, 244)">Логические операции и выражения</span>

Логические операции в C используются для составления сложных условий. Основные логические операторы:

- **&& (логическое И):** возвращает `true`, если оба операнда истинны
```c
if (a > 0 && b > 0) { /* Выполнится, если a и b больше 0 */ }
```

- **|| (логическое ИЛИ):** возвращает `true`, если хотя бы один из операндов истинен.
```c
if (a > 0 || b > 0) { /* Выполнится, если хотя бы одно из a или b больше 0 */ }
```

- **! (логическое НЕ):** возвращает `true`, если операнд ложен.
```c
if (!(a > 0)) { /* Выполнится, если a не больше 0 */ }
```

Логические выражения возвращают значения типа `int`, где `0` означает `false`, а любое ненулевое значение — `true`.

#### <span style="color:rgb(191, 138, 244)">Тернарный оператор в языке C</span>

Тернарный оператор (`?:`) — это компактная форма записи условного оператора `if`. Синтаксис:
```c
выражение ? значение_если_истина : значение_если_ложь;
```
Пример:

```c
int a = 5, b = 10;
int max = (a > b) ? a : b; // Если a > b, max = a; иначе max = b
```

Тернарный оператор используется для простых условий и возвращает значение, которое можно присвоить переменной.

```c
#include <stdio.h>

int main() {
    int a = 10, b = 20;
    // Использование if-else
    if (a > b) {
        printf("a больше b\n");
    } else {
        printf("a меньше или равно b\n");
    }
    // Использование логических операций
    if (a > 0 && b > 0) {
        printf("Обе переменные положительны\n");
    }
    // Использование тернарного оператора
    int max = (a > b) ? a : b;
    printf("Максимум: %d\n", max);
    return 0;
}
```

### <span style="color:rgb(197, 249, 154)">5. Операторы цикла в языке C. Управление выполнением тела операторов цикла</span>

Операторы цикла в языке C используются для многократного выполнения определенного блока кода, пока соблюдается заданное условие. 
#### <span style="color:rgb(191, 138, 244)">Основные операторы цикла</span>
#### 1. **`for`**

Цикл с заранее известным количеством итераций.  
Синтаксис:

```c
for (инициализация; условие; обновление) {
    // тело цикла
}
```

**Описание**:
- **Инициализация** выполняется один раз перед началом цикла.
- **Условие** проверяется перед каждой итерацией. Если оно ложно, цикл завершает выполнение.
- **Обновление** выполняется в конце каждой итерации.
```c
for (int i = 0; i < 5; i++) {
    printf("%d\n", i);
}
```
#### 2. **`while`**

Цикл с предусловием.  
Синтаксис:
```c
while (условие) {
    // тело цикла
}
```

**Описание**:
- Условие проверяется перед каждой итерацией. Если оно ложно, выполнение цикла завершается.
```c
int i = 0;
while (i < 5) {
    printf("%d\n", i);
    i++;
}
```
#### 3. **`do-while`**

Цикл с постусловием. Выполняет тело цикла как минимум один раз, даже если условие ложно.  
Синтаксис:
```c
do {
    // тело цикла
} while (условие);
```

**Описание**:
- Условие проверяется после выполнения тела цикла.
```c
int i = 0;
do {
    printf("%d\n", i);
    i++;
} while (i < 5);
```

#### <span style="color:rgb(191, 138, 244)">Управление выполнением тела операторов цикла</span>

#### 1) `break`

Прерывает выполнение цикла и передает управление за его пределы.  
Пример:
```c
for (int i = 0; i < 10; i++) {
    if (i == 5){
	    break;
	}
    printf("%d\n", i);
}
```

```c
0
1
2
3
4
```
#### 2) `continue`  

Прерывает текущую итерацию и переходит к следующей, минуя оставшуюся часть тела цикла.  
Пример:
```c
for (int i = 0; i < 10; i++) {
    if (i % 2 == 0){
	    continue;
    }
    printf("%d\n", i);
}
```

```c
1
3
5
7
9
```




### <span style="color:rgb(197, 249, 154)">6. Тип указателя. Арифметика указателей. Массивы и строки. Операции над строками и их непосредственная реализация</span>

### <span style="color:rgb(191, 138, 244)">Тип указателя</span>

==Указатель== — это переменная, которая хранит адрес памяти другой переменной. Тип указателя определяет размер и тип данных, на которые он указывает. Например:

- `int *p` — указатель на целое число.
- `float *p` — указатель на число с плавающей точкой.
- `char *p` — указатель на символ.

Тип указателя важен, поскольку по типу данных определяется, сколько ячеек памяти занимает значение, на которое ссылается указатель, и через сколько ячеек начнется следующее значение. Также тип указателя необходим для арифметики над указателями

### <span style="color:rgb(191, 138, 244)">Арифметика указателей</span>

#### Инкремент и декремент указателя

- Когда вы выполняете операцию инкремента (`++`) или декремента (`--`) над указателем, его значение изменяется не на 1, а на размер типа данных, на который он указывает. Это связано с тем, что указатель должен перемещаться по блокам памяти, размер которых соответствует типу данных
- Если целочисленный указатель, хранящий адрес 1000, уменьшить, то он уменьшится на 4  байта (размер int), и новый адрес будет показан как 996
#### Пример

![[Pasted image 20240920235125.png]]
```C
int a = 22;
int *p = &a;
printf("p = %u\n", p); // p = 6422288`
p++;
printf("p++ = %u\n", p); //p++ = 6422292    +4   // 4 bytes`
p--;
printf("p-- = %u\n", p); //p-- = 6422288     -4   // restored to original value`
```
*Спецификатор ==`%u`== позволяет получить значение указателя в форме `unsigned int`*
#### Добавление целого числа к указателю

- При добавлении к указателю  целого числа это число сначала умножается на размер типа данных, а затем добавляется к указателю
- Когда к указателю прибавляется целое число `n`, указатель перемещается на `n` элементов вперёд. То есть фактически он сдвигается на `n * sizeof(тип)` байт, где `тип` — это тип данных, на который указывает указатель
#### Пример с массивом

```C
int arr[5] = {10, 20, 30, 40, 50}; 
int *p = arr; // Указатель на первый элемент массива 
printf("Значение указателя p: %d\n", *p); // Выводит 10 
p = p + 2; // Перемещаем указатель на 2 элемента вперед 
printf("Значение указателя p после p + 2: %d\n", *p); // Выводит 30
```

*Здесь указатель `p` сначала указывает на первый элемент массива, а затем сдвигается на два элемента вперёд (на третий элемент массива)*

>[!Note]
>Указатель на имя массива и первый элемент равны

![[Pasted image 20240921001402.png]]

#### Вычитание одного указателя из другого

- Вычитание двух указателей возможно только тогда, когда они имеют одинаковый тип данных
- Результат генерируется путем вычисления разницы между адресами двух указателей и вычисления того, сколько байт данных это составляет в соответствии с типом данных указателя
- Пример: два целочисленных указателя, скажем, `ptr1` (адрес: 1000) и `ptr2` (адрес: 1004) вычитаются. Разница между адресами составляет 4 байта. Поскольку размер int составляет 4 байта, то приращение между `ptr1` и `ptr2` определяется как (4/4) = 1
#### Пример

```C
int arr[5] = {10, 20, 30, 40, 50}; 
int *p1 = &arr[1]; // Указатель на второй элемент массива 
int *p2 = &arr[4]; // Указатель на пятый элемент массива 
int difference = p2 - p1; // Разница между указателями 
printf("Разница между p2 и p1: %d\n", difference); // Выводит 3
```

### <span style="color:rgb(191, 138, 244)">Массивы и строки</span>

#### Массивы

Массивы представляют собой упорядоченные последовательности элементов одного типа, расположенные в памяти подряд
###### **Объявление массива и инициализация**

```c
int arr[5] = {1, 2, 3, 4, 5}; // Объявление и инициализация
int arr[5] = {0};             // Все элементы обнуляются
int arr[] = {10, 20, 30};     // Размер массива вычисляется автоматически (3 элемента)
```

###### **Связь массива и указателей**

Имя массива — это указатель на первый элемент:

```c
int arr[3] = {1, 2, 3};
int *ptr = arr;       // ptr указывает на arr[0]
printf("%d\n", *ptr); // 1
printf("%d\n", *(ptr + 1)); // 2
```
Однако размер массива нельзя получить через указатель, т.к. имя массива не сохраняет информации о длине.
При передаче массива в функцию передаётся указатель на его первый элемент
#### Строки

Строки представляют собой массивы символов, которые обязательно завершаются специальным символом `\0` (нулевой байт). Этот символ служит индикатором конца строки.
Строки в Си заканчиваются `\0`, поэтому массив для строки "Hello" должен быть размером минимум 6 (`5 символов + \0`).
К символам строки можно обращаться как к элементам массива
```c
char str[] = "Hello";
printf("%c\n", str[0]); // H
str[0] = 'J';           // Изменение строки: "Jello"
```
### <span style="color:rgb(191, 138, 244)">Операции над строками и их непосредственная реализация
</span>

###### 1) **`strcpy`** — <span style="color:rgb(191, 138, 244)">копирование строки</span>
```c
char *strcpy(char *dest, const char *src);
```
- **Аргументы**:
    - `dest` — указатель на строку, в которую будет копироваться содержимое.
    - `src` — указатель на исходную строку.
- **Возвращаемое значение**: указатель на строку `dest`.
#### <span style="color:rgb(237, 125, 164)">Реализация</span>
---
```c
char* my_strcpy(char *dest, const char *src) {
    char *original_dest = dest;  // Сохраняем указатель на начало dest
    while (*src != '\0'){
        *dest++ = *src++;
    }
    *dest = '\0';
    return original_dest;
}
```

######  2) **`strcmp`** — <span style="color:rgb(191, 138, 244)">сравнение строк</span>

- Используется для лексикографического (побайтового) сравнения двух строк
###### Принцип работы:
-  Сравниваются символы из обеих строк побайтно.
- Если символы равны, указатели сдвигаются вперёд (к следующему символу).
- Когда найдётся первый несовпадающий символ, вычисляется разность их ASCII-кодов
```c
int strcmp(const char *str1, const char *str2);
```

- **Аргументы**:
    - `str1` — указатель на первую строку.
    - `str2` — указатель на вторую строку.
- **Возвращаемое значение**:
    - **< 0**: если `str1` меньше, чем `str2`.
    - **0**: если строки равны.
    - **> 0**: если `str1` больше, чем `str2`.
#### <span style="color:rgb(237, 125, 164)">Реализация</span>
---
```c
int my_strcmp(const char *s1, const char *s2) {
    while (*s1 && (*s1 == *s2)) {
        s1++;
        s2++;
    }
    return *s1 - *s2;
}
```
######  3) **`strstr`** — <span style="color:rgb(191, 138, 244)">поиск подстроки</span>
```c
char *strstr(const char *haystack, const char *needle);
```
- **Аргументы**:
    - `haystack` — указатель на строку, в которой осуществляется поиск.
    - `needle` — указатель на подстроку, которую нужно найти.
- **Возвращаемое значение**: указатель на первое вхождение подстроки `needle` в строке `haystack` или `NULL`, если подстрока не найдена.
#### <span style="color:rgb(237, 125, 164)">Реализация</span>
---
```c
char *strstr(const char *haystack, const char *needle) {
    if (*needle == '\0') {
        return (char *)haystack; // Если needle пустая строка, вернуть haystack
    }
    for (const char *h = haystack; *h != '\0'; h++) {
        const char *h_start = h;
        const char *n = needle;

        while (*h_start != '\0' && *n != '\0' && *h_start == *n) {
            h_start++;
            n++;
        }
        if (*n == '\0') { // Если needle полностью совпал
            return (char *)h;
        }
    }
    return NULL; // needle не найден
}
```

#### Пояснения:

- Если `needle` (подстрока для поиска) — пустая строка (`*needle == '\0'`), то по стандарту функция должна вернуть `haystack` (указатель на начало строки-источника).
- Это объясняется тем, что пустая подстрока считается "найденной" в любом месте.
- `h_start` — копия текущего указателя `h` в `haystack`. Используется для сравнения символов.
- `n` — указатель на текущий символ в подстроке `needle`.
- Вложенный цикл проверяет, совпадают ли символы `haystack` (с текущей позиции `h_start`) и `needle`.
- Условия:
    - `*h_start != '\0'`: не выйти за пределы `haystack`.
    - `*n != '\0'`: не выйти за пределы `needle`.
    - `*h_start == *n`: символы совпадают.
- Если символы совпадают:
    - Указатели `h_start` и `n` продвигаются вперёд.
- Цикл завершается, если найдено несовпадение или достигнут конец `needle`.
######  4) **`strlen`** — <span style="color:rgb(191, 138, 244)">длина строки</span>
```c
size_t strlen(const char *str);
```
- **Аргументы**:
    - `str` — указатель на строку.
- **Возвращаемое значение**: количество символов в строке (без учёта `'\0'`).
#### <span style="color:rgb(237, 125, 164)">Реализация</span>
---
```c
int my_strlen (const char* str){
    int len = 0;
    while (*str != '\0'){
        len++;
        str++;
    }
    return len;
}
```

### <span style="color:rgb(197, 249, 154)">7. Конвертация чисел из строки и в строку. Схема Горнера и обратная схеме Горнера для преобразования строкового представления числа, записанного в заданной системе счисления, в значение целочисленного типа и наоборот, алгоритмическая сложность и реализация на языке C</span>

#### <span style="color:rgb(191, 138, 244)">Схема Горнера</span>

Схема Горнера (метод Горнера) — это способ оптимизации вычисления полинома, который снижает количество операций умножения.

![[Pasted image 20241125122323.png]]
![[Pasted image 20241125122422.png]]
![[Pasted image 20241125122522.png]]

```c
#include <stdio.h>

double horner(int coeffs[], int degree, double x) {
    double result = coeffs[0]; // Инициализация с первым коэффициентом

    for (int i = 1; i <= degree; i++) {
        result = result * x + coeffs[i];
    }

    return result;
}
```

- Таким образом, **метод Горнера** значительно эффективнее: он избегает возведения в степень, заменяя его на линейное количество умножений и сложений.
- Алгоритмическая сложность метода Горнера зависит от количества коэффициентов полинома. Пусть n — степень полинома.
###### Оценка сложности
1. **Количество операций сложения**: Для полинома степени n потребуется n операций сложения.
2. **Количество операций умножения**: Для полинома степени n потребуется n операций умножения.
Итого:
- **Общее число операций**: 2n.
- **Ассимптотическая сложность**: O(n).

#### <span style="color:rgb(191, 138, 244)">Схема Горнера. Конвертация  строки в заданной СС в число</span>

- используется для перевода строки, представляющей число, из любой СС в десятичную

```c
int stringToValue(const char* siz, int base){
	int res = 0;
	char *ps = siz;

	while (*ps){
		if (isalpha(*ps)){
			res = res * base + *ps++ - 'A' + 10;
		} else {
			res = res * base + *ps++ - '0';
		}
	}
	return res;
}
```
- Сложность О(n), где n - длина строки

#### <span style="color:rgb(191, 138, 244)">Обратная схема Горнера. Конвертация числа в строку в заданной СС</span>

- используется для перевода числа из десятичной СС в строку в заданной СС

```c
char* valueToString(int n, int base){
	char *buf = (char*)malloc(SIZE * sizeof(char));
	int r;
	char *pb = buf + SIZE- 1;
	*pb-- = '\0';
	while(n){
		*pb-- = ((r = n % base) > 9) ? r - 10 + 'A' : r + '0';
		n /= base;
	}
	pb++;
	return pb;
}
```

- Сложность O(log⁡b(n)), где b — основание системы счисления (пропорционально длине числа в системе счисления), n - входное число.
### <span style="color:rgb(197, 249, 154)">8. Файловый ввод/вывод в языке C. Методы чтения и записи файлов. Циклы чтения файлов с обработкой символа конца файла и без неё. Типизированные и нетипизированные файлы. Структура FILE. Форматируемый ввод/вывод. Методы выделения лексем из входного строкового потока. Принцип границы и функция strtok</span>

==`FILE`== — это структура, используемая для работы с файлами. Этот тип данных определяет поток и содержит информацию, необходимую для управления потоком.

В структуре содержатся следующие поля: режим открытия, права доступа, индикатор текущей позиции, указатель на буфер, размер буфера, состояние буфера (заполнен или пуст), поле для хранения дескриптора, флаги состояния, такие как индикатор конца файла (EOF)

Файлы хранятся на устройствах долговременного хранения данных, таких как жёсткие диски (HDD), флеш-накопители (USB) и другие носители, способные сохранять информацию при выключении питания.

---
Файловый дескриптор — это уникальный идентификатор, который операционная система назначает каждому открытому файлу в процессе выполнения программы.
Когда программа открывает файл, ОС выделяет ей файловый дескриптор (целое число), с помощью которого можно ссылаться на этот файл. Каждому открытому файлу,  ОС назначает свой дескриптор, и он остаётся активным до тех пор, пока файл не будет закрыт.
Файловые дескрипторы используются при низкоуровневых операциях, которые управляются системными вызовами. Например, в Unix-подобных системах функции `read()`, `write()`, `close()`.
Когда программа открывает файл с помощью функции, например, `open()` или `fopen()`, ОС выделяет ей свободный файловый дескриптор (целое число) и связывает его с таблицей, содержащей информацию о состоянии файла, его местоположении на диске и текущей позиции чтения/записи. Дескриптор хранится в таблице открытых файлов, и, используя его, программа может обращаться к файлу, не зная физического устройства или способа хранения данных.

---
#### Открытие и закрытие файла

```c
#include <stdio.h>

FILE *fopen(const char *filename, const char *mode);
int fclose(FILE *stream);
```

#### fopen()
- Если файл был успешно открыт, функция возвращает указатель на объект файла, который используется для идентификации потока и выполнения операций с файлом. 
- В противном случае, возвращается нулевой указатель.
#### fclose()
- Если файл успешно закрыт, возвращается нулевое значение.  
- В случае ошибки, возвращается `EOF`(-1)
```c
FILE *input = fopen(filename, "r");
    if (input == NULL){
        fprintf(stderr, "Error: Error open input file\n");
        return OPT_ERROR_FILE;
    }
```
#### <span style="color:rgb(191, 138, 244)">Методы чтения и записи файлов</span>
#### <span style="color:rgb(107, 199, 230)">1) Чтение</span>
###### Методы чтения:
##### - `fgetc`<span style="color:rgb(237, 125, 164)">: считывает один символ</span>

```c
int fgetc(FILE *stream);
```

Функция `fgetc` считывает один символ из указанного файла. Возвращает считанный символ (преобразованный в `unsigned char`, затем в `int`(по сути возвращает ASCII код символа)), `EOF`, если произошла ошибка или достигнут конец файла.

```c
int ch;
while ((ch = fgetc(file)) != EOF) { 
	putchar(ch); // выводим символ на экран 
}
```

####  - `fgets`<span style="color:rgb(237, 125, 164)">: считывает строку до конца строки или до указанного лимита</span>

```c
char *fgets(char *str, int n, FILE *stream);
```

Функция `fgets` считывает строку из файла до конца строки (`\n`), до достижения указанного лимита символов или до конца файла.

>[!Warning]
>Символ новой строки прекращает работу функции `fgets`, но он считается допустимым символом, и поэтому он копируется в строку `str`

**Аргументы**:
- `str`: указатель на буфер, куда будет записана строка.
- `n`: максимальное количество символов (включая завершающий `\0`).
- `stream`: указатель на структуру `FILE`.

**Возвращаемое значение**:
- Указатель на буфер `str`, если операция успешна.
- `NULL`, если произошла ошибка или достигнут конец файла без чтения данных

```c
char buffer[100];
while (fgets(buffer, sizeof(buffer), file) != NULL) { 
	printf("%s", buffer); // вывод строки на экран 
}
```

#### - `fscanf`<span style="color:rgb(237, 125, 164)">: форматируемое чтение данных</span>

```c
int fscanf(FILE *stream, const char *format, ...);
```

Функция `fscanf` считывает форматированные данные из файла, аналогично функции `scanf`, но с использованием файла.

>[!Warning]
>Все пробельные символы (включая `\n`) автоматически игнорируются между форматируемыми спецификаторами

**Аргументы**:
- `stream`: указатель на структуру `FILE`.
- `format`: строка формата, аналогичная строке формата `printf` (например, `%d`, `%s`).

**Возвращаемое значение**:
- Количество успешно считанных элементов.
- `EOF`, если достигнут конец файла до выполнения операции.

```c
int id; 
char name[50]; 
float score; 
while (fscanf(file, "%d %s %f", &id, name, &score) == 3) { 
	printf("ID: %d, Name: %s, Score: %.2f\n", id, name, score); 
}
```
#### - `fread`<span style="color:rgb(237, 125, 164)">: чтение блоков данных для типизированных файлов</span>

```c
size_t fread(void *ptr, size_t size, size_t count, FILE *stream);
```

Функция `fread` используется для чтения бинарных данных (типизированных файлов). Она считывает блоки данных фиксированного размера.

**Аргументы**:
- `ptr`: указатель на буфер, куда записываются данные.
- `size`: размер каждого элемента в байтах.
- `count`: количество элементов для чтения.
- `stream`: указатель на структуру `FILE`.

**Возвращаемое значение**:
- Количество успешно считанных элементов.
- Значение меньше `count`, если произошла ошибка или достигнут конец файла.

```c
struct Point {
    int x, y;
};

FILE *file = fopen("data.bin", "rb");
if (file == NULL) {
    perror("Error opening file");
    return 1;
}

struct Point p;
while (fread(&p, sizeof(struct Point), 1, file) == 1) {
    printf("Point: (%d, %d)\n", p.x, p.y);
}

fclose(file);
```

![[Pasted image 20241119015407.png]]

#### <span style="color:rgb(107, 199, 230)">2) Запись</span>

#### Методы записи

##### - `fputc`<span style="color:rgb(237, 125, 164)">: записывает один символ в указанный поток</span>

```c
int fputc(int c, FILE *stream);
```

Функция `fputc` записывает символ в поток и перемещает позицию индикатора положения. Символ записывается в текущую позицию в потоке `stream`, после чего, текущая позиция индикатора положения сдвигается на один символ. Символ для записи передается как значение типа `int`!

**Аргументы**:
- `c`: символ для записи (значение преобразуется в `unsigned char` перед записью).
- `stream`: указатель на структуру `FILE`, ассоциированную с файлом.

**Возвращаемое значение**:
- ASCII-код записанного символа при успешной записи.
- `EOF`, если произошла ошибка.

```c
FILE *file = fopen("example.txt", "w");
if (file == NULL) {
    perror("Error opening file");
    return 1;
}

fputc('A', file); 
fputc('\n', file); 

fclose(file);
```

##### - `fputs`<span style="color:rgb(237, 125, 164)">: записывает строку в файл</span>

```c
int fputs(const char *str, FILE *stream);
```

Символ завершения строки (`\0`) не записывается.
**Аргументы**:
- `str`: указатель на строку для записи.
- `stream`: указатель на структуру `FILE`.

**Возвращаемое значение**:
- Ноль при успешной записи.
- `EOF`, если произошла ошибка.

```c
FILE *file = fopen("example.txt", "w");
if (file == NULL) {
    perror("Error opening file");
    return 1;
}

fputs("Hello, World!", file); 
fclose(file);
```

##### - `fprintf`<span style="color:rgb(237, 125, 164)">: записывает форматированные данные в файл</span>
```c
int fprintf(FILE *stream, const char *format, ...);
```

Функция `fprintf` выполняет форматированный вывод в поток. Записывает в указанный поток последовательность символов в формате, указанном аргументом `format`. После параметра `format`, функция ожидает, по крайней мере, многие дополнительные аргументы, как указано в прототипе

**Аргументы**:
- `stream`: указатель на структуру `FILE`.
- `format`: строка формата (например, `%d`, `%s`, `%f`).
- Остальные параметры: значения для записи, в соответствии с форматом.

**Возвращаемое значение**:
- Количество успешно записанных символов.
- Отрицательное значение при ошибке.

```c
int id = 10; 
char name[] = "John"; 
float score = 95.5; 

fprintf(file, "ID: %d, Name: %s, Score: %.2f\n", id, name, score);
```

##### - `fwrite`<span style="color:rgb(237, 125, 164)">: записывает блоки данных в файл</span>
```c
size_t fwrite(const void *ptr, size_t size, size_t count, FILE *stream);
```

Используется для записи бинарных данных (структур, массивов и т.д.).

**Аргументы**:
- `ptr`: указатель на блок данных для записи.
- `size`: размер одного элемента (в байтах).
- `count`: количество элементов для записи.
- `stream`: указатель на структуру `FILE`.

**Возвращаемое значение**:
- Количество успешно записанных элементов.
- Если меньше `count`, произошла ошибка.

```c
struct Point {
    int x, y;
};

FILE *file = fopen("data.bin", "wb");
if (file == NULL) {
    perror("Error opening file");
    return 1;
}

struct Point p = {10, 20};
fwrite(&p, sizeof(struct Point), 1, file); 

fclose(file);
```
Запись создаёт файл `data.bin`, содержащий бинарное представление структуры `Point`

![[Pasted image 20241119015318.png]]
#### <span style="color:rgb(191, 138, 244)">Циклы чтения файлов с обработкой символа конца файла и без неё</span>

- **С обработкой символа конца файла (`EOF`)**: Символ `EOF` возвращается функциями вроде `fgetc` или `fscanf`, чтобы указать конец файла.
```c
int ch; 
while ((ch = fgetc(file)) != EOF) { 
	putchar(ch); // выводим символ на экран 
}
```

```c
int number; 
while (fscanf(file, "%d", &number) != EOF) { 
	printf("Read number: %d\n", number); 
}
```
- **Без явной обработки `EOF`**: Использование функции `feof` для проверки конца файла.

```c
int ch;
while (!feof(file)){
	putchar(ch);
}
```

```c
int id; 
char name[50]; 
float score; 
while (fscanf(file, "%d %s %f", &id, name, &score) == 3) { 
	printf("ID: %d, Name: %s, Score: %.2f\n", id, name, score); 
}
```
#### <span style="color:rgb(191, 138, 244)">Типизированные и нетипизированные файлы</span>

==Типизированные файлы== - работа с данными определённого типа (например, структуры, числа).
- Используются `fread` и `fwrite`.

==Нетипизированные файлы== - работа с текстовыми данными, строками, символами.
- Используются `fgetc`, `fgets`, `fprintf`
#### <span style="color:rgb(191, 138, 244)">Методы выделения лексем из входного строкового потока</span>

##### <span style="color:rgb(107, 199, 230)">Программа, которая читает символы из файла и выводит на экран последовательности буквенно-цифровых символов</span>

#### Ввод:
1123,   45! hru7%
#### Вывод:
1123
45
hru7


```C
FILE *fl = NULL;
char ch, c = '\0'; // текущий символ и предыдущий символ
char buf [BUFSIZ], *pb = buf;
if ((fl = fopen("input.txt", "r")) == NULL){
	printf("Error: Cannot open input file\n");
	return 1;
}
while (!feof(fl)){
	ch = fgetc(fl);
	if(isalnum(ch)){
		*pb ++= ch;
	}else if (isalnum(c)){ //если предыдущий буква/цифра, то слово закончилось
		*pb = '\0';
		printf("%s\n", buf);
		pb = buf; // сбрасываем указатель на начало буфера
	}
	c = ch;	
}
fclose(fl);
```
#### <span style="color:rgb(191, 138, 244)">Принцип границы и strtok()</span>

Функция `strtok()` в C используется для разбора строки на части (токены) с использованием разделителей. Она определена в библиотеке `string.h` и позволяет выделять слова или подстроки, разделённые определёнными символами.
###### Как работает `strtok()`?

Функция `strtok()` принимает два аргумента:

1. **Строка для разбора** (или `NULL`, если разбор продолжается с предыдущей строки),
2. **Строка-разделитель**, которая содержит символы, по которым нужно разделить строку.

###### Принцип работы:

- При первом вызове `strtok()` передают строку для разбора и строку-разделитель. Функция ищет первый токен — подстроку до первого символа-разделителя.
- `strtok()` заменяет первый найденный разделитель в исходной строке на символ конца строки (`'\0'`), чтобы завершить токен, и возвращает указатель на начало токена.
- Для получения следующих токенов передают `NULL` вместо строки для разбора. В таком случае функция продолжает работу с позиции сразу после предыдущего разделителя и ищет следующий токен.
- Когда больше нет токенов, функция возвращает `NULL`.
```c
int main() { 
	char str[] = "Hello, world! Welcome to C programming."; 
	char *token = strtok(str, " ,.!"); 
	while (token != NULL) { 
		printf("%s\n", token);  
		token = strtok(NULL, " ,.!"); 
	}
}	
```

>[!Tip]
>Функция `strtok` изменяет исходную строку, заменяя разделители на `\0`, поэтому при повторном использовании строки она будет видоизменена. Для сохранения исходных данных лучше работать с копией строки

>[!Note]
>NULL - работает как флаг, указывая на то, что разбор происходит не с начала строки

![[Pasted image 20241119025350.png]]

### <span style="color:rgb(197, 249, 154)">9. Функции. Способы передачи аргументов в функции. Возврат значений из функции через возвращаемое значение, через параметры функции. Глобальные и локальные переменные. Область видимости переменных. Модификатор static</span>

#### <span style="color:rgb(191, 138, 244)">Функции. Формальное определение</span>

В C функции представляют собой блоки кода, которые выполняют определенную задачу и могут принимать аргументы и возвращать значения. 

```c
тип_возвращаемого_значения имя_функции(параметры){
	выполняемые_инструкции
}
```

![[Pasted image 20241114171949.png]]

Первая строка представляет заголовок или сигнатуру функции. Вначале указывается возвращаемый тип функции. Если функция не возвращает никакого значения, то используется тип void.
Затем идет имя функции, которое представляет произвольный идентификатор, к которому применяются те же правила, что и к именованию переменных.
После имени функции в круглых скобках идет перечисление параметров. Функция может не иметь параметров, в этом случае указываются пустые скобки.
После заголовка функции в фигурных скобках идет тело функции, которое содержит выполняемые выражения.
#### <span style="color:rgb(191, 138, 244)">Способы передачи аргументов в функции</span>

###### В C существует два основных способа передачи аргументов в функции:

- ==**Передача по значению**==: при этом способе в функцию передается копия значения аргумента. Изменение параметра внутри функции не влияет на значение переменной, переданной в качестве аргумента. 
#### Пример:
```c
void foo(int x) {
    x = 10;
}

int main() {
    int a = 5;
    foo(a);
    printf("%d\n", a); // выведет 5
    return 0;
}
```

- ==**Передача по указателю**==: в этом случае в функцию передается адрес переменной, что позволяет изменять значение переменной, находящейся в памяти. Изменения внутри функции отразятся на переданной переменной. 
#### Пример:
```c
void foo(int *x) {
    *x = 10;
}

int main() {
    int a = 5;
    foo(&a);
    printf("%d\n", a); // a изменится на 10
    return 0;
}
```

#### <span style="color:rgb(191, 138, 244)">Возврат значений из функции через возвращаемое значение, через параметры функции</span>

1) **Через возвращаемое значение**: функция может возвращать значение, указав его тип перед именем функции. Для этого используется оператор `return`. Оператор `return` также завершает выполнение функции и передает управление следующему оператору в вызывающей функции.
#### Пример
```c
int add(int a, int b) {
    return a + b;
}
```

2) **Через параметры функции**: если необходимо вернуть несколько значений, часто используют указатели в параметрах функции, чтобы функция могла изменять переданные ей переменные
#### Пример
```c
void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}
```

### <span style="color:rgb(191, 138, 244)">Глобальные и локальные переменные</span>

- **Глобальные переменные**: определены вне всех функций и доступны из любой функции в пределах того же файла (если не используется `static`). Эти переменные существуют на протяжении всей программы.
- **Локальные переменные**: определены внутри функций или блоков кода и видны только в пределах этого блока. Они создаются при входе в блок и уничтожаются при выходе.
### <span style="color:rgb(191, 138, 244)">Область видимости переменных</span>

- Переменные, определенные в функции или блоке кода, имеют **локальную область видимости** и доступны только внутри данного блока.
- Глобальные переменные имеют **глобальную область видимости** и могут быть доступны во всем файле.
### <span style="color:rgb(191, 138, 244)">Модификатор</span> `static`

#### 1. Локальные переменные (внутри функций)

Когда переменная внутри функции объявлена как **`static`**, она сохраняет своё значение между вызовами функции. Это значит, что её продолжительность жизни — всё время работы программы, а не только во время исполнения функции. Однако её область видимости остаётся локальной для этой функции.
#### Пример:
```C
void counter() {
    static int count = 0;  // Переменная сохраняет своё значение между вызовами
    count++;
    printf("Counter: %d\n", count);
}

int main() {
    counter();  // Выведет 1
    counter();  // Выведет 2
    counter();  // Выведет 3
    return 0;
}
```
- В данном примере переменная `count` будет инициализирована один раз при первом вызове функции `counter`, и её значение будет сохраняться между вызовами функции.

#### 2. Глобальные переменные и функции

Когда переменная или функция объявлена как **`static`** в глобальной области (вне функций), она становится **локальной для файла**, в котором объявлена. Это означает, что она **не видна за пределами этого файла** (то есть имеет внутреннее связывание), что позволяет ограничить область видимости и предотвращает конфликты с другими глобальными переменными или функциями в других файлах.
#### Пример:
```C
static int globalVar = 10;  // Эта переменная доступна только в текущем файле

static void printMessage() {
    printf("Hello from static function!\n");
}

void someFunction() {
    printMessage();  // Эта функция доступна только в этом файле
}
```
- Переменная `globalVar` и функция `printMessage` объявлены как `static`, поэтому они видны только в этом файле и недоступны из других файлов программы.


### <span style="color:rgb(197, 249, 154)">10.  Функции с переменным числом аргументов. Типы данных и основные макросы для работы со списком аргументов переменной длины. Указатели на функции. Массив указателей на функции. Функция atexit</span>

#### <span style="color:rgb(191, 138, 244)">Функции с переменным числом аргументов</span>

Функции с переменным числом аргументов позволяют передавать неопределённое количество аргументов. Для их создания в C используется специальный синтаксис и макросы, находящиеся в заголовке `<stdarg.h>`.
#### Основные макросы из `<stdarg.h>`

1. `va_list` — тип данных для хранения списка аргументов.
2. `va_start` — инициализирует список аргументов.
3. `va_arg` — возвращает следующий аргумент из списка.
4. `va_end` — завершает обработку списка аргументов.
#### 1. va_list
```c
va_list ap;
```
`va_list` — это тип данных в языке C, который используется для работы с переменным количеством аргументов в функции (вариативные функции). Он объявляет объект, который хранит информацию о переменных аргументах. Этот объект передаётся макросам, таким как `va_start`, `va_arg` и `va_end`, для доступа к переменным аргументам. Переменная этого типа не хранит сами аргументы напрямую, а содержит информацию о том, где в памяти находятся переменные аргументы. Когда функция получает переменное количество аргументов, эти аргументы передаются в стек, и `va_list` содержит указатели на их местоположение. Макросы `va_start`, `va_arg` и `va_end` позволяют извлекать аргументы из этой переменной по одному.
#### 2. va_start

Макрос `va_start` инициализирует объект `va_list`, чтобы он мог использоваться для извлечения дополнительных аргументов переменной длины. Этот макрос настраивает `va_list` так, чтобы он "знал", где в памяти начинаются аргументы, которые передаются после последнего обязательного параметра функции.
```c
#define va_start(ap, parm) (ap) = (char*)(&(parm) + 1)
```

*`parm` - последний явно переданный параметр*
```c
void va_start(va_list ap, last);
```
##### Синтаксис
- `ap`: Это объект типа `va_list`, который будет содержать информацию о текущем положении в списке аргументов.
- `last`: Это имя последнего именованного (обязательного) аргумента функции, который предшествует переменным аргументам.
#### Как работает `va_start`

Когда функция вызывается, её аргументы размещаются либо на стеке, либо в регистрах (в зависимости от архитектуры). Макрос `va_start` настраивает `va_list` так, чтобы он указывал на первый из дополнительных аргументов после `last`. Внутри `va_start` компилятор использует знание о положении `last`, чтобы вычислить адрес следующего аргумента
#### 3. va_arg

```c
#define va_arg(ap, type) ((type*)((char*)(ap)+=sizeof(type)))[-1]
```
  
// *[-1] имя указателя + смещение + разыменование //сдвинуться на следующий, получить значение предыдущего*

Макрос `va_arg` используется для доступа к каждому отдельному аргументу из списка переменных аргументов, который был инициализирован с помощью `va_start`. Он позволяет поочередно получать переданные аргументы, указывая их тип.
```c
type va_arg(va_list ap, type);
```
##### Синтаксис
- **`ap`**: Это объект типа `va_list`, который был ранее инициализирован макросом `va_start`. Он содержит информацию о текущей позиции в списке аргументов.
- **`type`**: Это тип следующего аргумента, который вы хотите получить. Вы должны явно указать тип каждого аргумента, так как компилятор не знает их типов заранее.
- `ptr[i]`эквивалентно `*(ptr + i)`
- Системное программирование на UNIX
- Имя функции - указатель на область памяти, где располагается тело функции
##### Как работает `va_arg`:

1. **Получение аргумента**: `va_arg` возвращает значение следующего аргумента в списке, преобразованного к указанному типу.
2. **Переход к следующему аргументу**: После вызова `va_arg` указатель `va_list` обновляется для того, чтобы указывать на следующий аргумент в списке.
### 4. va_end

Макрос `va_end` используется для завершения работы с переменным списком аргументов. Он освобождает все ресурсы, которые могли быть выделены для объекта типа `va_list`, после того как была закончена работа с переменными аргументами.
```c
void va_end(va_list ap);
```
##### Синтаксис
- **`ap`**: Это объект типа `va_list`, который был инициализирован с помощью `va_start`. После вызова `va_end` этот объект больше нельзя использовать для извлечения аргументов.
##### Как работает `va_end`:
- **Завершение**: Макрос завершает работу с переменными аргументами. В большинстве случаев это просто приводит к тому, что внутренние указатели, используемые в объекте `va_list`, сбрасываются или очищаются.

#### Пример

```c
#include <stdio.h>
#include <stdarg.h>

void print_numbers(int count, ...) {
    va_list args; 
    va_start(args, count); 
    for (int i = 0; i < count; i++) {
        int num = va_arg(args, int); 
        printf("%d ", num);
    }
    va_end(args); 
    printf("\n");
}

int main() {
    print_numbers(3, 10, 20, 30);
    print_numbers(5, 1, 2, 3, 4, 5);
    return 0;
}
```

#### <span style="color:rgb(191, 138, 244)">Указатели на функции</span>

Указатели на функции позволяют передавать функции как аргументы другим функциям.

#### Пример

```c
#include <stdio.h>

int sum(int a, int b) {
    return a + b;
}

int main() {
    int (*func_ptr)(int, int) = sum; 
    printf("Sum: %d\n", func_ptr(5, 10)); 
    return 0;
}
```

```c
#include <stdio.h>

int add(int a, int b) { return a + b; }
int subtract(int a, int b) { return a - b; }

int calculate(int (*operation)(int, int), int x, int y) {
    return operation(x, y);
}

int main() {
    printf("Sum: %d\n", calculate(add, 5, 3)); 
    printf("Difference: %d\n", calculate(subtract, 5, 3));
    return 0;
}
```

#### <span style="color:rgb(191, 138, 244)">Массив указателей на функции</span>

Массив указателей на функции позволяет хранить несколько функций в одном массиве и вызывать их по индексу.
#### Пример

```c
#include <stdio.h>

int add(int a, int b) { return a + b; }
int subtract(int a, int b) { return a - b; }
int multiply(int a, int b) { return a * b; }

int main() {
    int (*operations[])(int, int) = { add, subtract, multiply };

    int x = 10, y = 5;
    printf("Add: %d\n", operations[0](x, y));
    printf("Subtract: %d\n", operations[1](x, y));
    printf("Multiply: %d\n", operations[2](x, y));
    
    return 0;
}
```

#### <span style="color:rgb(191, 138, 244)">Функция atexit</span>

Функция `atexit()` регистрирует функцию, которая будет выполнена при нормальном завершении работы программы. Всего может быть зарегистрировано по меньшей мере 32 функции, которые будут выполнены при завершении работы в порядке обратном порядку регистрации. Также можно несколько раз зарегистрировать одну и ту же функцию. Она будет вызвана столько раз, сколько раз была зарегистрирована.

#### Синтаксис

```c
int atexit(void (*func)(void));
```

- **`func`** — указатель на функцию, которая должна быть вызвана при завершении программы. Эта функция не принимает аргументов и не возвращает значения (`void`).
- Возвращаемое значение — `atexit` возвращает `0` при успешной регистрации функции и ненулевое значение, если регистрация не удалась (например, если исчерпан лимит на количество функций для регистрации).

>*Стандарт C требует, чтобы реализация поддерживала регистрацию минимум 32 функций. В большинстве реализаций поддерживается гораздо больше, но количество ограничено*

#### Пример

```c
#include <stdio.h>
#include <stdlib.h>

void first() {
    printf("Exit first!\n");
}
void second() {
    printf("Exit second!\n");
} 
void third() {
    printf("Exit third!\n");
} 
int main() {
    // Регистрируем функции, которые должны выполниться при завершении программы
    atexit(first);
    atexit(second);
    atexit(third);
    printf("Program is running...\n");
    return 0;
}
```

```c
Program is running...
Exit third!
Exit second!
Exit first!
```

### <span style="color:rgb(197, 249, 154)">11. Динамическое выделение памяти. Функции malloc, calloc, realloc, free. Оператор sizeof</span>

Динамическое выделение памяти позволяет программам выделять память во время выполнения, а не заранее. Это необходимо, когда объем памяти, необходимый программе, заранее неизвестен. Основные функции для динамического выделения и освобождения памяти находятся в библиотеке `stdlib.h`

#### <span style="color:rgb(191, 138, 244)">Динамическое выделение памяти</span>
### 1. **`malloc`** (Memory Allocation)

Функция **`malloc`** выделяет блок памяти заданного размера и возвращает указатель на первый байт этого блока. Память не инициализируется (то есть она содержит "мусорные" значения).
#### Синтаксис:
```C
void* malloc(size_t size);
```
- **`size`** — количество байт для выделения.
- Возвращает **указатель** на выделенную память или **`NULL`**, если выделение не удалось.
#### Пример:
```c
int *arr = (int*) malloc(10 * sizeof(int));  // Выделяем память для 10 целых чисел
if (arr == NULL) {
    printf("Error: Memory allocation error\n");
}
```
- Функция **`malloc`** возвращает **указатель типа `void*`**, что означает "указатель на неопределённый тип". Необходимо использовать приведение типа.
- Вызов **`malloc(0)`** ведет себя по-разному в зависимости от реализации стандартной библиотеки C, но по стандарту C, результат должен быть один из двух:

	1. **`malloc(0)` возвращает указатель на блок памяти минимального размера**, который может быть нулевым (не используемый, но корректный указатель). Этот указатель можно передать в **`free`** позже. В некоторых реализациях выделение небольших блоков (в том числе и нулевых) выполняется через внутренние механизмы управления памятью, которые не проверяют точный размер запрашиваемого блока. Поэтому может вернуться "фиктивный" указатель, который не обязательно указывает на полезную область памяти. Операционная система может выделить минимально возможный блок памяти. Например, некоторые системы выделяют блок размером 1 байт, даже если вы запросили 0 байт, поскольку выделение памяти всегда происходит блоками фиксированного минимального размера. **Фиктивный указатель** в контексте вызова **`malloc(0)`** — это указатель, который указывает на какую-то область памяти, но не обязательно на реально выделенный блок, пригодный для использования.
	2. **`malloc(0)` возвращает `NULL`**, если не удается выделить память или если выделение "нулевого" размера не поддерживается системой.
### 2.**`calloc`** (Contiguous Allocation)

Функция **`calloc`** выделяет память для массива из элементов заданного размера и инициализирует всю выделенную память нулями.
#### Синтаксис:
```c
void* calloc(size_t num, size_t size);
```
- **`num`** — количество элементов.
- **`size`** — размер одного элемента в байтах.
- Возвращает **указатель** на выделенную память или **`NULL`**, если выделение не удалось.
#### Пример:
```c
int *arr = (int*) calloc(10, sizeof(int));  // Выделяем память для 10 целых чисел и инициализируем её нулями
if (arr == NULL) {
    printf("Error: Memory allocation error\n");
}
```
### 3. **`realloc`** (Reallocation)

Функция **`realloc`** изменяет размер уже выделенного блока памяти. Она может переместить блок в другое место, если текущего места недостаточно для нового размера.
#### Синтаксис:
```c
void* realloc(void* ptr, size_t new_size);
```
- **`ptr`** — указатель на ранее выделенный блок памяти. Если **`ptr`** равен **`NULL`**, `realloc` работает как `malloc`.
- **`new_size`** — новый размер блока памяти в байтах.
- Возвращает **указатель** на новый блок памяти или **`NULL`**, если выделение не удалось (в этом случае исходный блок остаётся без изменений).

>[! Note]
>При использовании функции `realloc` необходимо использовать дополнительный указатель для проверки, чтобы избежать утечки памяти в случае ошибки перераспределения
#### Пример:
```c
int *ptr = (int*)malloc(10 * sizeof(int));
int *temp = (int*)realloc(ptr, 20 * sizeof(int)); 
if (temp != NULL) { 
	ptr = temp; 
} else { 
	free(ptr);
    printf("Error: Memory reallocation error\n");
}
```
*Используем дополнительный указатель, старый не перезаписывается и в случае ошибки ранее выделенная память корректно освобождается*
### Принцип работы `realloc`:

![[Pasted image 20241111005932.png]]

1. **Если новая область памяти больше исходной**:
    
    - **`realloc`** выделяет новый блок памяти нужного размера.
    - Затем копирует содержимое старого блока в новый блок. Копируется столько байт, сколько было в старом блоке (или меньше, если указано меньший размер).
    - Если новый размер больше, чем исходный, дополнительная память в новом блоке не инициализируется (так же, как в случае с `malloc`).
    - Старый блок освобождается, и возвращается указатель на новый блок.
2. **Если новая область меньше исходной**:
    
    - В этом случае **`realloc`** может уменьшить размер текущего блока, если это возможно, или выделить новый, меньший блок.
    - Часть данных, которая "не поместилась" в новый размер, может быть потеряна.
3. **Если удается расширить текущий блок**:
    
    - Если текущий блок памяти можно расширить без перемещения данных, то память увеличивается "на месте", и данные остаются на прежнем месте.
###  4. **`free`** (Memory Deallocation)

Функция **`free`** освобождает ранее выделенный блок памяти, возвращая его операционной системе. После вызова **`free`** указатель становится недействительным, и использование памяти по этому указателю может привести к неопределённому поведению.
#### Синтаксис:
```c
void free(void* ptr);
```
- **`ptr`** — указатель на блок памяти, который нужно освободить. Если **`ptr`** равен **`NULL`**, ничего не происходит.
#### Пример:
```c
int *arr = (int*) malloc(10 * sizeof(int));  // Выделяем память для 10 целых чисел
free(arr);  // Освобождаем память
```
#### Важные моменты:

- **Не забывать освобождать память** с помощью функции `free`, чтобы избежать утечек памяти.
- После вызова `free`, лучше присвоить указателю значение **`NULL`** для предотвращения доступа к освобождённой памяти.
#### Как free() узнаёт, сколько памяти следует освободить?

- **Выделение памяти:** Системный аллокатор выделяет немного больше памяти, чем запрашивается. Например, если вы запросили 100 байт, на самом деле может быть выделено больше, чем 100 байт.
- **Скрытые метаданные:** Перед тем участком памяти, который возвращается пользователю, аллокатор записывает метаданные, которые содержат информацию о размере выделенного блока, а также другую служебную информацию, необходимую для управления памятью.

Таким образом, когда мы передаём указатель в `free()`, аллокатор использует этот указатель, чтобы обратиться к скрытым метаданным, которые находятся до этого указателя. Эти метаданные содержат информацию о том, сколько памяти было выделено для данного блока. Таким образом, используя метаданные, функция `free()` узнает, какой объем памяти нужно освободить.

#### <span style="color:rgb(191, 138, 244)">Оператор sizeof()</span>

Оператор `sizeof`  возвращает размер объекта или типа в байтах. Это встроенный оператор, который позволяет определить, сколько байтов памяти занимает переменная, структура, массив или другой тип данных

###### Оператор `sizeof` можно применять двумя способами:
1. Для переменной или выражения:
```c
sizeof(variable);
```
    
2. Для типа данных:
```c
sizeof(type);
```

```c
int size_of_int = sizeof(int); // Вернет размер типа int, обычно 4 байта
```

###### Особенности `sizeof`

- `sizeof` не выполняет вычислений над содержимым переменной или выражения, а только определяет размер типа или объекта.
    
- Для указателей `sizeof` возвращает размер указателя, а не размера данных, на которые он указывает. 
```c
int *ptr;
size_t ptr_size = sizeof(ptr); // Возвращает размер указателя 4 байта
```

### <span style="color:rgb(197, 249, 154)">12. Структуры и объединения в языке C, их размер, определение и особенности использования. Оператор “.”. Указатели на структуры в языке C, оператор “->”</span>

#### <span style="color:rgb(191, 138, 244)">Структуры</span>

==Структура== - это сложный тип данных представляющий собой упорядоченное в памяти множество элементов различного типа.
Структуры в языке программирования C позволяют объединять данные разных типов в одну сущность. Это полезно, когда нужно хранить связанные данные вместе, например, информацию о человеке, где может быть имя, возраст и рост.
##### Объявление структуры
```c
struct MyStr{ 
	int x, y;
	char ch;
	char s[256];
	int *ptr;
};
```
##### Создание переменной типа struct MyStr
```c
struct MyStr st;
st.x = 10; // присвоение значений полям структуры
st.y = st.x + 2;
strcpy(st.s, "Hello!");
```

Здесь определена переменная `st`, которая представляет структуру `MyStr`. И при каждом определении переменной типа структуры ей будет выделяться память, необходимая для хранения ее элементов.
##### Упрощение с typedef

В C `typedef` используется для создания псевдонимов типов, в том числе и для структуры. Это позволяет упростить синтаксис, чтобы не писать ключевое слово `struct` каждый раз, когда нужно использовать определённый тип структуры

```c
struct Person { // 1 вариант объявления структуры
	char name[50];
	int age; 
	float height; 
};

typedef struct { // 2 вариант объявления структуры
	char name[50]; 
	int age; 
	float height; 
} Person;

Person person1; // тогда для создания переменной не нужен struct
person1.age = 25; 
person1.height = 175.5;
```
###### В данном примере:

- Мы объявили структуру `Person`, содержащую три поля `name`, `age` и `height`.
- Затем, используя `typedef`, создали псевдоним `Person` для этой структуры.
- Теперь можно создавать переменные типа `Person` без необходимости указывать `struct` перед именем типа
##### Размер структуры
Размер структуры в Cи зависит от нескольких факторов, включая размер её членов и выравнивание (alignment). Компиляторы часто вставляют промежутки (память, не используемую для хранения данных), чтобы каждый член структуры был выровнен на границу, соответствующую его размеру. Это позволяет улучшить производительность, так как процессоры могут быстрее работать с выровненными данными.
###### Размер структуры определяется с учётом:
1. Размер каждого поля структуры
2. Требования выравнивания: Компилятор может добавлять "паддинг" (дополнительную память) между полями для их выравнивания по границе байтов

```c
struct Example { 
	char a; // 1 байт 
	int b; // 4 байта 
	char c; // 1 байт 
};

int main() { 
	printf("Size of struct Example: %lu\n", sizeof(struct Example)); 
	return 0; 
}
```

*Однако, чтобы `int b` был выровнен на 4-байтовую границу, компилятор добавляет 3 байта после `char a`. После `char c` также может добавляться паддинг, чтобы размер структуры был кратен размеру самого большого поля (в данном случае это 4 байта)*
*Размер структуры будет: 1 + 3 (паддинг) + 4 + 1 + 3 (паддинг) = 12 байт

>[!Note]
>При определении размерности структуры использовать `sizeof()`

##### Указатель на структуру

Используется для работы с динамически выделенными объектами или для передачи структуры в функции. Доступ к полям структуры через указатель осуществляется с помощью оператора `->` (стрелочка), который является синтаксическим сокращением для работы с указателями на структуры.


```c
struct MyStr *pStr = NULL;
pStr = &st;
```
##### Обращение к полям структуры, 2 способа:

- **Оператор `->`** используется для доступа к полям структуры через указатель
- **Оператор `(*ptr).field`** — альтернатива для доступа к полям через указатель, однако он менее удобен, чем `->`
```c
(*personPtr).age = 10;
personPtr->age = 10;
```
#### Пример

```c
#include <stdio.h>
#include <stdlib.h>

// Определение структуры
struct Person {
    char name[50];
    int age;
    float height;
};

int main() {
    // Создание указателя на структуру
    struct Person *personPtr;
    // Выделение памяти для структуры в динамической памяти
    personPtr = (struct Person *)malloc(sizeof(struct Person));
    // Присвоение значений полям структуры через указатель
    personPtr->age = 30;
    personPtr->height = 180.5;
    snprintf(personPtr->name, sizeof(personPtr->name), "Alice");

    // Доступ к полям структуры через указатель
    printf("Name: %s\n", personPtr->name);
    printf("Age: %d\n", personPtr->age);
    printf("Height: %.2f\n", personPtr->height);

    // Освобождение выделенной памяти
    free(personPtr);
    return 0;
}
```

*Память под структуру выделяется при помощи `malloc`  в случае, если размер структуры неизвестен на момент компиляции (например, структура содержит динамический массив) или структура должна жить дольше, чем время выполнения функции, где она создана.*

#### <span style="color:rgb(191, 138, 244)">Объединения</span>

==Объединение== (`union`) — это тип данных, который позволяет хранить в одной и той же области памяти переменные разных типов, но только одну переменную в каждый конкретный момент времени. Все члены объединения занимают одно и то же место в памяти, и её размер равен размеру самого большого члена. Это полезно, когда нужно экономить память и знать, что в определённый момент времени будет использоваться только одно из полей объединения.

*// все поля располагаются в одной области памяти, берём только одно поле из объединения*
```c
union Data {
    int i;
    float f;
    char str[20];
};

int main() {
    union Data data;
    data.i = 10;
    printf("data.i = %d\n", data.i);
    data.f = 220.5;
    printf("data.f = %.1f\n", data.f);
    // При записи в поле `str` предыдущее значение (`f`) будет затёрто
    strcpy(data.str, "Hello");
    printf("data.str = %s\n", data.str);
    // Внимание: попытка прочитать значение из другого поля будет некорректной
    printf("data.i after str assignment = %d\n", data.i); // Выведет мусор
    return 0;
}
```
##### Отличия от структур

1. **Память**: В отличие от структуры, где память выделяется для каждого члена отдельно, объединение выделяет память только для самого большого члена. Это значит, что если один член объединения изменен, данные других членов могут быть перезаписаны.
    
2. **Использование**: Используется там, где необходимо работать с разными типами данных, но в один момент времени используется только одно из них.
##### Пример использования
```c
#include <stdio.h> 
union Data { 
	int i; 
	float f; 
	char str[20];
}; 
int main() { 
	union Data data; 
	data.i = 10; 
	printf("data.i = %d\n", data.i); 
	data.f = 220.5; 
	printf("data.f = %.1f\n", data.f); 
}
// Поскольку объединение хранит только одно значение за раз, 
// предыдущее значение (data.i) будет перезаписано
```

*Как узнать, что лежит в данный момент в `union` ? - Никак*

### <span style="color:rgb(197, 249, 154)">13. Директивы препроцессора в языке C. Порядок работы препроцессора. Директивы #include, #define, #ifdef, #ifndef, #endif, #, ##, их назначение, особенности и примеры использования. Особенности конструирования замещающих значений для макроопределений в языке C</span>

Препроцессор в языке C обрабатывает исходный код до этапа компиляции. Он выполняет текстовые замены и выполняет различные команды (==_директивы препроцессора_==). Директивы начинаются с символа `#` и выполняются на этапе подготовки к компиляции.
#### <span style="color:rgb(191, 138, 244)">Порядок работы препроцессора</span>

1. **Удаление комментариев**: Препроцессор удаляет все комментарии, упрощая исходный код.
2. **Замена макросов**: Все макроопределения (`#define`) заменяются на соответствующие значения.
3. **Обработка включений (`#include`)**: Включает содержимое указанных файлов в текущий файл.
4. **Условная компиляция**: Условные директивы (`#ifdef`, `#ifndef`, `#if`, `#else`, `#elif`, `#endif`) управляют тем, какие части кода будут включены в результат.
5. **Обработка операторов `#` и `##`**: Используется для макросов и их аргументов, что позволяет управлять текстом и значениями аргументов макросов.
#### <span style="color:rgb(191, 138, 244)">1. Директива</span> `#include`

`#include` используется для включения содержимого другого файла, например, заголовочного файла. Существует два способа указания файла:

- `#include <file.h>`: включает стандартный заголовочный файл из системных библиотек.
- `#include "file.h"`: включает пользовательский заголовочный файл из текущего каталога (или из каталогов, указанных компилятору).
#### Пример:
```c
#include <stdio.h> 
#include "myheader.h"
```

#### <span style="color:rgb(191, 138, 244)">2. Директива</span> `#define`

`#define` используется для создания ==_макросов_==. 
==Макросы в C== — это конструкции, позволяющие заменить часть кода на заданное выражение во время препроцессинга, то есть до начала компиляции программы. Макросы определяются с помощью директивы `#define` и выполняют текстовую замену в коде. Макросы часто используются для создания именованных констант
###### Типы макросов: макросы-константы, функциональные макросы
```c
#define PI 3.14159 
#define MAX_LENGTH 100
```

```c
#define SQUARE(x) ((x) * (x)) 
#define MAX(a, b) ((a) > (b) ? (a) : (b))
```
- не имеют проверок типов, подвержены ошибкам
#### <span style="color:rgb(191, 138, 244)">3. Директивы условной компиляции</span> `#ifdef`, `#ifndef`, `#endif`

Эти директивы позволяют включать или исключать код в зависимости от наличия определённого макроса.

- **`#ifdef MACRO`** – код внутри блока будет скомпилирован, если `MACRO` определён.
- **`#ifndef MACRO`** – код будет скомпилирован, если `MACRO` не определён.
- **`#endif`** завершает условный блок.

**`#ifdef` и `#ifndef`** (если определено / если не определено):
    
    - #ifdef проверяет, определён ли макрос.
    - #ifndef проверяет, не определён ли макрос.
    
	Эти директивы обычно используются для того, чтобы включить код, если макрос
    существует, или исключить, если не существует.

```c
#define DEBUG // Определяем макрос DEBUG 

#ifdef DEBUG 
printf("Debugging is enabled\n"); // Этот код будет включён 
#endif 

#ifndef RELEASE 
printf("Release mode is disabled\n"); // Этот код тоже будет включён 
#endif
```
#### <span style="color:rgb(191, 138, 244)">4. Операторы # и ## в макросах</span>

#### Оператор `#`

`#` используется для превращения аргумента макроса в строковый литерал. Это называется _строковым преобразованием_ (stringizing). При добавлении `#` перед аргументом в макросе, препроцессор автоматически преобразует переданный аргумент в строку.
```c
#include <stdio.h>

#define STRINGIFY(x) #x

int main() {
    printf("%s\n", STRINGIFY(Hello World));   // Выведет: Hello World
    printf("%s\n", STRINGIFY(123 + 456));     // Выведет: 123 + 456
    return 0;
}
```

В  примере:
- `STRINGIFY(Hello World)` превратит `Hello World` в строку `"Hello World"`.
- `STRINGIFY(123 + 456)` превратит выражение `123 + 456` в строку `"123 + 456"`.

> **Важно**: Оператор `#` создаёт строковый литерал с точным значением переданного аргумента, включая пробелы и символы.
#### Оператор `##`

Оператор `##` используется для объединения (конкатенации) двух токенов в макросе. Когда препроцессор встречает `##` между двумя аргументами, он объединяет их в один идентификатор.
#### Синтаксис:
```c
#define CONCAT(a, b) a ## b
```
``
```c
#include <stdio.h>
#define CONCAT(a, b) a ## b

int main() {
    int CONCAT(num, 1) = 10;  // Создаст переменную с именем num1
    printf("num1 = %d\n", num1);  // Выведет: num1 = 10
    return 0;
}
```

В  примере:
- `CONCAT(num, 1)` объединяет `num` и `1`, создавая идентификатор `num1`.
- В результате код `int num1 = 10;` будет скомпилирован и выведет значение `10`.

```c
#include <stdio.h>

#define UNIQUE_VAR(base) base ## __LINE__

int main() {
    int UNIQUE_VAR(temp) = 5;   // Создаст переменную temp23 (номер строки)
    int UNIQUE_VAR(temp) = 10;  // Создаст переменную temp24 (номер строки)
    
    printf("temp23 = %d\n", temp23);
    printf("temp24 = %d\n", temp24);
    return 0;
}
```

Здесь макрос `UNIQUE_VAR` объединяет имя `base` с номером текущей строки (`__LINE__` — это специальный макрос, который возвращает номер строки), создавая уникальные идентификаторы `temp23` и `temp24`. Это полезно для создания временных переменных, когда нужны уникальные имена в пределах одной функции.
#### <span style="color:rgb(191, 138, 244)">5. Особенности конструирования замещающих значений для макроопределений</span>

1. **Использование скобок**: Чтобы избежать приоритетных ошибок, рекомендуется всегда использовать скобки в макросах с выражениями.
```c
#define MULTIPLY(x, y) ((x) * (y))
```

2. **Многострочные макросы**: Для создания макросов, состоящих из нескольких строк, используется `\` в конце каждой строки, кроме последней.
```c
#define PRINT_DEBUG(x) \ 
	printf("Debug: %d\n", x); \ 
	printf("Line: %d\n", __LINE__);
```

### <span style="color:rgb(197, 249, 154)">14. Создание и обработка динамических массивов. Методы перераспределения памяти при работе с динамическими массивами, их вычислительные сложности. Операций добавления/удаления элемента, доступа к элементу по индексу и по значению, их вычислительные сложности. Реализация взаимодействия с динамическим массивом на языке C</span>

==**Динамические массивы** ==— это массивы, размер которых может изменяться во время выполнения программы. Они создаются в области динамической памяти, которая управляется вручную с использованием функций, таких как `malloc`, `calloc`, `realloc` и `free`
#### <span style="color:rgb(191, 138, 244)">Создание и обработка динамического массива</span>

Создать динамический массив можно с помощью следующих функций:

1. **`malloc`**: Выделяет память без её инициализации.
    ```c
    int *arr = (int *)malloc(n * sizeof(int));
```
    
2. **`calloc`**: Выделяет и инициализирует память (заполняет нулями).
    ```c
    int *arr = (int *)calloc(n, sizeof(int));

```
    
3. **`realloc`**: Изменяет размер ранее выделенного блока памяти.
    ```c
    arr = (int *)realloc(arr, new_size * sizeof(int));

```
    
4. `free(arr)`: Освобождает память
#### <span style="color:rgb(191, 138, 244)">Методы перераспределения памяти при работе с динамическими массивами, их вычислительные сложности</span>

#### `realloc`<span style="color:rgb(237, 125, 164)">: Увеличение/уменьшение памяти</span>

- **Увеличение памяти**:
    
    - Если есть достаточно свободного пространства в текущем блоке, размер увеличивается "на месте", и указатель остается тем же. Это очень быстро — **O(1)**.
    - Если свободного пространства нет, выделяется новый блок памяти достаточного размера, данные из старого блока копируются в новый, а старый блок освобождается. В этом случае сложность **O(n)**, где n — размер данных, которые нужно скопировать.
    
- **Уменьшение памяти**:
    - Если новый размер меньше текущего, обычно память уменьшается "на месте", и указатель остается прежним. Часть памяти, которая больше не используется, может быть помечена как свободная.
    - Иногда уменьшение размера может привести к перемещению данных (редкий случай, зависит от реализации аллокатора).
#### Особенности уменьшения памяти с `realloc`

- **Уменьшение "на месте"**: Если блок памяти можно уменьшить без перемещения (освободив лишнюю часть в конце), это происходит быстро, без копирования данных, за **O(1)**.
    
- **Перемещение блока**: В редких случаях уменьшение памяти может привести к выделению нового блока меньшего размера и копированию данных в него. Это зависит от конкретной реализации `realloc` в библиотеке стандартных функций C и текущего состояния менеджера памяти.
    
- **Неизменная часть данных**: При уменьшении памяти данные, которые укладываются в новый размер, остаются без изменений.
    
- **Поведение при нулевом размере**: Если `new_size == 0`, то память освобождается, аналогично вызову `free(ptr)`.
#### <span style="color:rgb(191, 138, 244)">Операции добавления/удаления элемента, доступа к элементу по индексу и по значению, их вычислительные сложности</span>

#### Добавление элемента

```c
errorCode addElement(int *arr, int *size, int *capacity, int value) { 
	if (*size == *capacity) { 
		*capacity *= 2;  
		int* new_arr = (int *)realloc(arr, *capacity * sizeof(int)); 
		if (new_arr == NULL) { 
			fprintf(stderr, "Error: Memory allocation error\n"); 
			free(arr);
			return MEMORY_ERROR; 
		}else{
			arr = new_arr;
		}
	} 
	arr[*size] = value; 
	(*size)++; 
	return OPT_SUCCES;
}
```
#### Удаление элемента

```c
errorCode removeElement(int *arr, int *size, int index) {
	if (index >= *size || index < 0) { 
		printf("Error: The index is out of range\n"); 
		return OPT_ERROR; 
	} 
	for (int i = index; i < *size - 1; i++) {
		arr[i] = arr[i + 1]; 
	} 
	(*size)--; 
	return OPT_SUCCES;
}
```
#### Доступ к элементу по индексу

- Прямая адресация через указатель: **O(1)**

```c
int value = arr[i];
```

#### Поиск элемента по значению

- Требуется перебор всех элементов: **O(n)**
```c
for (int i = 0; i < n; i++) {
    if (arr[i] == value) {
        // элемент найден
    }
}
```

![[Pasted image 20241119161951.png]]

### <span style="color:rgb(197, 249, 154)">15. Списочные структуры данных. Односвязные, двусвязные и кольцевые списки. Вычислительные сложности операций доступа к элементу (по индексу/значению), вставки/удаления элементов для списков соответствующего типа, их реализация на языке C</span>

**Списочные структуры данных** — это линейные структуры, состоящие из узлов, где каждый узел содержит данные и ссылки на другие узлы.

---
### <span style="color:rgb(191, 138, 244)">Односвязный список</span>

Односвязный список состоит из узлов, каждый из которых содержит:

- **Данные** — значение, которое хранится в узле.
- **Указатель** на следующий узел.

Первый узел списка называется **головой (head)**, а последний узел указывает на `NULL`
#### <span style="color:rgb(237, 125, 164)">Структура элемента односвязного списка</span>

```c
struct Node{
	int data;
	struct Node* pNext;
};
```

#### <span style="color:rgb(237, 125, 164)">Создание узла</span>

```c
struct Node* createNode(int data, int* errorCode) {
	struct Node* newNode = (struct Node*)malloc(sizeof(struct Node)); 
	if (newNode == NULL){
		*errorCode = -1;
		return NULL;
	}
	*errorCode = 0;
	newNode->data = data; 
	newNode->next = NULL; 
	return newNode; 
}
```
- Сложность О(1)
#### <span style="color:rgb(237, 125, 164)">Вставка в начало</span>

```c
void push_front(struct Node** head, int data, int* errorCode) { 
	struct Node* newNode = createNode(data, errorCode); 
	if (*errorCode != 0){
		return;
	}
	*errorCode = 0;
	newNode->next = *head; 
	*head = newNode; 
}
```
- Сложность О(1)
#### <span style="color:rgb(237, 125, 164)">Вставка в конец</span>

```c
void push_back(struct Node** head, int data, int* errorCode) { 
	struct Node* newNode = createNode(data, errorCode); 
	if (*errorCode != 0){
		return;
	}

	*errorCode = 0;
	if (*head == NULL) { 
		*head = newNode;
		return; 
	} 
	struct Node* temp = *head; 
	while (temp->next != NULL) { 
		temp = temp->next; 
	} 
	temp->next = newNode; 
}
```
- Сложность О(n)

#### <span style="color:rgb(237, 125, 164)">Удаление списка</span>

```c
void destroy(struct Node** head) {
    struct Node* current = *head;
    struct Node* nextNode = NULL;

    while (current != NULL) {
        nextNode = current->next; 
        free(current);            
        current = nextNode;       
    }

    *head = NULL; 
}
```
- Сложность О(n)

#### <span style="color:rgb(237, 125, 164)">Вставка после указанного узла</span>

```c
void insert_after(struct Node* prevNode, int data, int* errorCode) {
	if (prevNode == NULL) { 
		*errorCode = -2; 
		return; 
	} 
	struct Node* newNode = createNode(data, errorCode); 
	if (*errorCode != 0) { 
		return;  
	} 
	newNode->next = prevNode->next; 
	prevNode->next = newNode;
}
```
- Сложность О(1)
#### <span style="color:rgb(237, 125, 164)">Удаление после указанного узла</span>

```c
void remove_after(struct Node* prevNode, int* errorCode) {
    if (prevNode == NULL) {
        *errorCode = -2; // Ошибка: передан NULL в prevNode
        return;
    }

    struct Node* nodeToRemove = prevNode->next;
    if (nodeToRemove == NULL) {
        *errorCode = -2; // Ошибка: за prevNode нет узла для удаления
        return;
    }
	*errorCode = 0;
    prevNode->next = nodeToRemove->next; 
    free(nodeToRemove); 
}
```
- Сложность О(1)
#### <span style="color:rgb(237, 125, 164)">Доступ к элементу по индексу</span>

```c
int getElementByIndex(struct Node* head, int index, int* errorCode) {
    int currentIndex = 0;
    struct Node* current = head;
    // Проходим по списку до нужного индекса
    while (current != NULL) {
        if (currentIndex == index) {
            *errorCode = 0; 
            return current->data;         
        }
        current = current->next;
        currentIndex++;
    }

    // Если индекс вне границ
    *errorCode = -1; 
    return -1;                 
}
```
- Сложность О(n)
#### <span style="color:rgb(237, 125, 164)">Доступ к элементу по значению</span>

```c
struct Node* getElementByValue(struct Node* head, int value, int* errorCode) {
    struct Node* current = head;

    // Ищем узел с заданным значением
    while (current != NULL) {
        if (current->data == value) {
            *errorCode = 0; 
            return current;            
        }
        current = current->next;
    }

    // Если узел не найден
	*errorCode = -1; 
    return NULL;                 
}
```
- Сложность О(n)
#### <span style="color:rgb(237, 125, 164)">Индус рассказывает алгоритм вставки в односвязный список</span>

![[Pasted image 20241123214804.png]]

### <span style="color:rgb(191, 138, 244)">Двусвязный список</span>

#### <span style="color:rgb(237, 125, 164)">Структура узла двусвязного списка и самого списка</span>

```c
// Структура узла двусвязного списка 
typedef struct Node { 
	int data; 
	struct Node* next; 
	struct Node* prev; 
} Node; 
// Структура для двусвязного списка 
typedef struct DoublyLinkedList { 
	Node* head; 
	Node* tail; 
} DoublyLinkedList;
```

#### <span style="color:rgb(237, 125, 164)">Инициализация списка и создание нового узла</span>

```c
// Функция инициализации списка 
DoublyLinkedList* create_list() { 
	DoublyLinkedList* list = (DoublyLinkedList*)malloc(sizeof(DoublyLinkedList));      if (!list) { 
		return NULL; 
	} 
	list->head = NULL; 
	list->tail = NULL; 
	return list; 
} 
// Функция создания нового узла 
Node* create_node(int value, int* errorCode) { 
	Node* new_node = (Node*)malloc(sizeof(Node)); 
	if (!new_node) { 
		*errorcode = -1;  
		return NULL; 
	} 
	new_node->data = value; 
	new_node->next = NULL; 
	new_node->prev = NULL; 
	*errorCode = 0; 
	return new_node; 
}
```
- Сложность О(1)
#### <span style="color:rgb(237, 125, 164)">Вставка в конец списка</span>

```c
void push_back(DoublyLinkedList* list, int value, int* errorCode) {
    if (!list) {
        *errorCode = -1; // Список не инициализирован
        return;
    }
    Node* newNode = createNode(value, errorCode);
    if (*errorCode != 0) return;

    if (list->tail == NULL) {
        // Список пуст, вставляем первый элемент
        list->head = list->tail = newNode;
    } else {
        list->tail->next = newNode;
        newNode->prev = list->tail;
        list->tail = newNode;
    }
    *errorCode = 0;
}
```
- Сложность О(1)
#### <span style="color:rgb(237, 125, 164)">Вставка в начало списка</span>

```c
void push_front(DoublyLinkedList* list, int value, int* errorCode) {
    if (!list) {
        *errorCode = -1; // Список не инициализирован
        return;
    }
    Node* newNode = createNode(value, errorCode);
    if (*errorCode != 0) return;

    if (list->head == NULL) {
        // Список пуст, новый узел становится и головой, и хвостом
        list->head = list->tail = newNode;
    } else {
        // Вставляем перед текущей головой
        newNode->next = list->head;
        list->head->prev = newNode;
        list->head = newNode;
    }

    *errorCode = 0; 
}
```
- Сложность О(1)
#### <span style="color:rgb(237, 125, 164)">Вставка после указанного узла</span>

```c
void insert_after(Node* node, int value, int* errorCode) {
    if (!list) {
        *errorCode = -1; // Список не инициализирован
        return;
    }
    Node* newNode = createNode(value, errorCode);
    if (*errorCode != 0) return;
    
    newNode->next = node->next;
    newNode->prev = node;

    if (node->next) {
        node->next->prev = newNode;
    }
    node->next = newNode;

    *errorCode = 0; 
}
```
- Сложность О(1)
#### <span style="color:rgb(237, 125, 164)">Удаление узла из начала списка</span>

```c
void pop_front(DoublyLinkedList* list, int* errorCode) {
    if (!list || !list->head) {
        *errorCode = -1; // Список пуст или не инициализирован
        return;
    }

    Node* temp = list->head;

    if (list->head == list->tail) {
        // Если в списке только один элемент
        list->head = list->tail = NULL;
    } else {
        // Перемещаем голову на следующий узел
        list->head = list->head->next;
        list->head->prev = NULL;
    }

    free(temp);
    *errorCode = 0;
}
```
- Сложность О(1)
#### <span style="color:rgb(237, 125, 164)">Удаление узла из конца списка</span>

```c
void pop_back(DoublyLinkedList* list, int* errorCode) {
    if (!list || !list->tail) {
        *error = -1; // Список пуст или не инициализирован
        return;
    }

    Node* temp = list->tail;

    if (list->head == list->tail) {
        // Если в списке только один элемент
        list->head = list->tail = NULL;
    } else {
        // Перемещаем хвост на предыдущий узел
        list->tail = list->tail->prev;
        list->tail->next = NULL;
    }

    free(temp);
    *errorCode = 0; 
}
```
- Сложность О(1)
#### <span style="color:rgb(237, 125, 164)">Удаление узла по значению</span>

```c
void deleteByValue(DoublyLinkedList* list, int value, int* errorCode) {
    if (!list || !list->head) {
        *errorCode = -1; // Список пуст или не инициализирован
        return;
    }

    Node* current = list->head;
    while (current) {
        if (current->data == value) {
            // Удаляем текущий узел
            if (current->prev) current->prev->next = current->next;
            if (current->next) current->next->prev = current->prev;

            // Если это голова или хвост списка
            if (current == list->head) list->head = current->next;
            if (current == list->tail) list->tail = current->prev;

            free(current);
            *errorCode = 0;
            return;
        }
        current = current->next;
    }
    *errorCode = -2; // Узел с таким значением не найден
}
```
- Сложность О(n)
#### <span style="color:rgb(237, 125, 164)">Доступ к элементу по индексу</span>

```c
Node* getByIndex(DoublyLinkedList* list, int index, int* errorCode) {
    if (!list || index < 0) {
        *errorCode = -1; // Список не инициализирован или индекс некорректен
        return NULL;
    }

    Node* current = list->head;
    int currentIndex = 0;

    while (current && currentIndex < index) {
        current = current->next;
        currentIndex++;
    }

    if (!current) {
        *errorCode = -2; // Элемент с таким индексом не найден
        return NULL;
    }

    *errorCode = 0; // Ошибок нет
    return current;
}
```
- Сложность О(n)
#### <span style="color:rgb(237, 125, 164)">Доступ к элементу по значению</span>

```c
Node* getByValue(DoublyLinkedList* list, int value, int* errorCode) {
    if (!list) {
        *errorCode = -1; // Список не инициализирован
        return NULL;
    }

    Node* current = list->head;

    while (current) {
        if (current->data == value) {
            *errorCode = 0; // Элемент найден, ошибок нет
            return current;
        }
        current = current->next;
    }

    *errorCode = -2; // Элемент с таким значением не найден
    return NULL;
}
```
- Сложность О(n)
#### <span style="color:rgb(237, 125, 164)">Удаление списка</span>

```c
void destroy(DoublyLinkedList* list) {
    if (!list) return;

    Node* current = list->head;
    while (current) {
        Node* temp = current;
        current = current->next;
        free(temp);
    }
    free(list);
}
```
- Сложность О(n)
### <span style="color:rgb(191, 138, 244)">Кольцевой список</span>

Кольцевой список (или круговой список) — это структура данных, в которой последний элемент связан с первым, образуя кольцо. В языке C такую структуру можно реализовать с помощью односвязного или двусвязного списка.
В данном случае односвязный список

#### <span style="color:rgb(237, 125, 164)">Структура узла</span>

```c
typedef struct Node {
	int data; 
	struct Node* next; 
} Node;
```

#### <span style="color:rgb(237, 125, 164)">Создание узла</span>

```c
Node* createNode(int data, int *errorCode) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    if (!newNode) {
        *errorCode = -1; 
        return NULL;
    }

    newNode->data = data;
    newNode->next = NULL;
    *errorCode = 0; 
    return newNode;
}
```
- Сложность О(1)
#### <span style="color:rgb(237, 125, 164)">Вставка в начало списка</span>

```c
void push_front(Node** head, int data, int *errorCode) {
    Node* newNode = createNode(data, errorCode);
    if (*errorCode != 0) {
        return;
    }

    if (*head == NULL) {
        *head = newNode;
        newNode->next = *head; // Ссылка на самого себя
    } else {
        Node* temp = *head;
        while (temp->next != *head) {
            temp = temp->next; // Доходим до последнего узла
        }
        temp->next = newNode;
        newNode->next = *head;
        *head = newNode;
    }

    *errorCode = 0; 
}
```
- Сложность О(n)
#### <span style="color:rgb(237, 125, 164)">Вставка в конец списка</span>

```c
void insertAtEnd(Node** head, int data, int *errorCode) {
    Node* newNode = createNode(data, errorCode);
    if (*errorCode != 0) {
        return;
    }

    if (*head == NULL) {
        // Если список пуст, новый узел становится головой и ссылается на себя
        *head = newNode;
        newNode->next = *head;
    } else {
        Node* temp = *head;
        while (temp->next != *head) {
            temp = temp->next;
        }
        // Вставляем новый узел в конец
        temp->next = newNode;
        newNode->next = *head;
    }

    *errorCode = 0;
}
```
- Сложность О(n)
#### <span style="color:rgb(237, 125, 164)">Вставка после указанного узла</span>

```c
void insertAfterNode(Node* node, int data, int *errorCode) {
    if (!node) {
        *errorCode = 2; // Указанный узел NULL
        return;
    }

    Node* newNode = createNode(data, errorCode);
    if (*errorCode != 0) {
        return;
    }

    newNode->next = node->next;
    node->next = newNode;

    *errorCode = 0; 
}
```
- Сложность О(1)
#### <span style="color:rgb(237, 125, 164)">Удаление из начала списка</span>

```c
void pop_front(Node** head, int *errorCode) {
    if (*head == NULL) {
        *errorCode = -1; // Список пуст
        return;
    }

    Node* temp = *head;

    if ((*head)->next == *head) {
        // В списке только один элемент
        free(*head);  
        *head = NULL; 
    } else {
        Node* tail = *head;
        while (tail->next != *head) {
            tail = tail->next;
        }
        tail->next = (*head)->next; 
        *head = (*head)->next;
        free(temp); 
    }
    *errorCode = 0; 
}
```
- Сложность О(n)
#### <span style="color:rgb(237, 125, 164)">Удаление из конца списка</span>

```c
void pop_back(Node** head, int *errorCode) {
    if (*head == NULL) {
        *errorCode = -1; // Список пуст
        return;
    }

    Node* temp = *head;

    if ((*head)->next == *head) {
        // В списке только один элемент
        free(*head);  
        *head = NULL; 
    } else {
        Node* prev = NULL;
        while (temp->next != *head) {
            prev = temp;
            temp = temp->next;
        }
        prev->next = *head; // Устанавливаем новый конец списка
    }

    free(temp);
    *errorCode = 0; 
}
```
- Сложность О(n)
#### <span style="color:rgb(237, 125, 164)">Удаление по значению</span>

```c
void deleteByValue(Node** head, int value, int *errorCode) {
    if (*head == NULL) {
        *errorCode = 1; // Список пуст
        return;
    }

    Node* temp = *head;
    Node* prev = NULL;

    // Если голова содержит значение
    if (temp->data == value) {
        pop_front(head, errorCode);
        return;
    }

    do {
        prev = temp;
        temp = temp->next;
        if (temp->data == value) {
            prev->next = temp->next;

            // Если удаляем узел, который был последним
            if (temp == *head) {
                *head = prev->next;
            }

            free(temp);
            *errorCode = 0; // Успешное выполнение
            return;
        }
    } while (temp != *head);

    *errorCode = -2; // Значение не найдено
}
```
- Сложность О(n)
#### <span style="color:rgb(237, 125, 164)">Доступ к элементу по значению</span>

```c
Node* getNodeByValue(Node* head, int value, int *errorCode) {
    if (head == NULL) {
        *errorCode = -1; // Список пуст
        return NULL;
    }

    Node* temp = head;

    do {
        if (temp->data == value) {
            *errorCode = 0; // Элемент найден
            return temp;
        }
        temp = temp->next;
    } while (temp != head);

    *errorCode = -2; // Элемент с указанным значением не найден
    return NULL;
}
```
- Сложность О(n)
#### <span style="color:rgb(237, 125, 164)">Доступ к элементу по индексу</span>

```c
Node* getNodeByIndex(Node* head, int index, int *errorCode) {
    if (head == NULL) {
        *errorCode = -1; // Список пуст
        return NULL;
    }

    Node* temp = head;
    int count = 0;

    do {
        if (count == index) {
            *errorCode = 0; // Элемент найден
            return temp;
        }
        temp = temp->next;
        count++;
    } while (temp != head);

    *errorCode = -2; // Индекс выходит за пределы списка
    return NULL;
}
```
- Сложность О(n)
#### <span style="color:rgb(237, 125, 164)">Удаление списка</span>

```c
void destroy(Node** head) {
    if (*head == NULL) {
        return; // Список уже пуст
    }

    Node* current = *head;
    Node* nextNode;

    do {
        nextNode = current->next; // Сохраняем указатель на следующий узел
        free(current);            // Освобождаем текущий узел
        current = nextNode;       // Переходим к следующему узлу
    } while (current != *head);

    *head = NULL; // Устанавливаем список в пустое состояние
}
```
- Сложность О(n)

### <span style="color:rgb(197, 249, 154)">16. Списочные структуры данных. Очереди и стеки. Организация очереди и стека на основе односвязного списка. Вычислительные сложности операций доступа к элементу, вставки и удаления элементов для стека и очереди, их реализация на языке C. Алгоритм проверки баланса скобок в выражении</span>

### <span style="color:rgb(191, 138, 244)">Очередь на односвязном списке</span>

#### <span style="color:rgb(237, 125, 164)">Структура для элемента очереди и для самой очереди</span>

```c
// Узел односвязного списка 
typedef struct Node {
	int data; 
	struct Node* next; 
} Node; 
// Очередь 
typedef struct Queue { 
	Node* first; // Указатель на первый элемент очереди 
	Node* last; // Указатель на последний элемент очереди 
	int size; // Текущий размер очереди 
} Queue;
```

#### <span style="color:rgb(237, 125, 164)">Создание очереди</span>

```c
Queue* createQueue() {
	Queue* queue = (Queue*)malloc(sizeof(Queue)); 
	queue->first = NULL; 
	queue->last = NULL; 
	queue->size = 0; 
	return queue; 
}
```
- Сложность О(1)
#### <span style="color:rgb(237, 125, 164)">Вставка элемента в конец очереди</span>

```c
void push_back(Queue* queue, int value) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = value;
    newNode->next = NULL;

    if (queue->last == NULL) { // Если очередь пуста
        queue->first = newNode;
        queue->last = newNode;
    } else {
        queue->last->next = newNode;
        queue->last = newNode;
    }
    queue->size++; // Увеличиваем размер очереди
}
```
- Сложность О(1)
#### <span style="color:rgb(237, 125, 164)">Удаление элемента из начала очереди</span>

```c
errorCode pop_front(Queue* queue, int* value) {
    if (queue->first == NULL) { // Если очередь пуста
        return EMPTY_QUEUE; // Код ошибки
    }
    Node* temp = queue->first;
    *value = temp->data;
    queue->first = queue->first->next;

    if (queue->first == NULL) { // Если очередь стала пустой
        queue->last = NULL;
    }
    free(temp); // Удаляем узел
    queue->size--; // Уменьшаем размер очереди
    return OPT_SUCCES;
}
```
- Сложность О(1)
#### <span style="color:rgb(237, 125, 164)">Доступ к первому и последнему элементу очереди</span>

```c
errorCode front(Queue* queue, int* value) {
    if (queue->first == NULL) { // Если очередь пуста  
        return EMPTY_QUEUE;     // Возвращаем код ошибки
    }
    *value = queue->first->data;             
    return OPT_SUCCES;  
}

errorCode back(Queue* queue, int* value) {
    if (queue->last == NULL) {  // Если очередь пуста
        return EMPTY_QUEUE;     // Возвращаем код ошибки
    }
    *value = queue->last->data;             
    return OPT_SUCCES;   
}
```
- Сложность О(1)
#### <span style="color:rgb(237, 125, 164)">Удаление очереди</span>

```c
void destroy(Queue* queue) {
    while (queue->first != NULL) {
	    int value;
        pop_front(queue, &value); // Удаляем каждый узел (и освобождаем его память)
    }
    free(queue); // Освобождаем память под структуру Queue
}
```
- Сложность О(n)
### <span style="color:rgb(191, 138, 244)">Стек на односвязном списке</span>
#### <span style="color:rgb(237, 125, 164)">Структура для элемента стека и для самого стека</span>

```c
// Узел односвязного списка 
typedef struct Node { 
	int data; 
	struct Node* next; 
} Node; 
// Стек 
typedef struct Stack { 
	Node* top; // Указатель на вершину стека 
	int size; // Текущий размер стека 
} Stack;
```
#### <span style="color:rgb(237, 125, 164)">Создание стека</span>

```c
Stack* createStack() {
    Stack* stack = (Stack*)malloc(sizeof(Stack));
    stack->top = NULL;
    stack->size = 0;
    return stack;
}
```
- Сложность О(1)
#### <span style="color:rgb(237, 125, 164)">Вставка элемента в вершину стека</span>

```c
void push_back(Stack* stack, int value) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->data = value;
    newNode->next = stack->top;
    stack->top = newNode;
    stack->size++;
}
```
- Сложность О(1)
#### <span style="color:rgb(237, 125, 164)">Удаление элемента с вершины стека</span>

```c
errorCode pop_back(Stack* stack, int* value) {
    if (stack->top == NULL) { // Если стек пуст       
        return EMPTY_STACK;   // Возвращаем код ошибки
    }

    Node* temp = stack->top;
    *value = temp->data;
    stack->top = stack->top->next;
    free(temp); // Освобождаем память узла
    stack->size--;
    return OPT_SUCCES;
}
```
- Сложность О(1)
#### <span style="color:rgb(237, 125, 164)">Доступ к верхнему элементу стека</span>

```c
errorCode back(Stack* stack, int* value) {
    if (stack->top == NULL) { // Если стек пуст
        return EMPTY_STACK;   // Возвращаем код ошибки
    }
    *value = stack->top->data;         
    return OPT_SUCCES;  // Возвращаем значение верхнего элемента
}
```
- Сложность О(1)
#### <span style="color:rgb(237, 125, 164)">Проверка на пустоту</span>

```c
int isEmpty(Stack* stack) {
	return stack->top == NULL; 
}
```
- Сложность О(1)
#### <span style="color:rgb(237, 125, 164)">Удаление стека</span>

```c
void destroy(Stack* stack) {
    while (stack->top != NULL) {
	    int value;
        pop_back(queue, &value); // Удаляем каждый узел (и освобождаем его память)
    }
    free(stack); // Освобождаем память под структуру 
}
```
- Сложность О(n)
### <span style="color:rgb(191, 138, 244)">Алгоритм проверки баланса скобок в выражении</span>

- Пройти по каждому символу выражения.
- Если символ — открывающая скобка (`'('`, `'{'`, `'['`), поместить её в стек.
- Если символ — закрывающая скобка (`')'`, `'}'`, `']'`):
    - Проверить, не пуст ли стек (если пуст, значит несбалансировано).
    - Сравнить тип закрывающей скобки с верхней открытой скобкой из стека.
    - Если типы не совпадают, выражение несбалансировано.
    - Если совпадают, удалить верхнюю скобку из стека.
- В конце проверить стек:
    - Если стек пуст, скобки сбалансированы.
    - Если не пуст, выражение несбалансировано.
    
```c
int isBalanced(const char* expression) {
    Stack* stack = createStack();

    while (*expression) { // Перемещаемся по строке через указатель
        char ch = *expression;

        if (ch == '(' || ch == '{' || ch == '[') {
            push_back(stack, ch);
        } else if (ch == ')' || ch == '}' || ch == ']') {
            if (isEmpty(stack)) {
                destroy(stack);
                return 0; // Несбалансировано
            }

            char top;
            pop(stack, &top);
            if ((ch == ')' && top != '(') ||
                (ch == '}' && top != '{') ||
                (ch == ']' && top != '[')) {
                destroy(stack);
                return 0; // Несбалансировано
            }
        }

        expression++; // Переход к следующему символу
    }

    int balanced = isEmpty(stack);
    destroyStack(stack);
    return balanced;
}
```
- Сложность О(n)
```c
bool isBalanced(const char* expression) {
    Stack* stack = createStack();

    while (*expression) {
        char ch = *expression;

        if (ch == '(') {
            push(stack, ch); // Добавляем открывающую скобку в стек
        } else if (ch == ')') {
            if (isEmpty(stack)) {
                // Если стек пуст, то закрывающая скобка не имеет пары
                destroy(stack);
                return false;
            }
            char top;
            pop_back(stack, &top); // Удаляем верхнюю скобку из стека
        }

        expression++; // Переход к следующему символу
    }

    // Если стек пуст, скобки сбалансированы
    bool balanced = isEmpty(stack);
    destroy(stack);
    return balanced;
}
```


### <span style="color:rgb(197, 249, 154)">17. Префиксная, инфиксная и постфиксная форма арифметического выражения. Алгоритм конвертации строкового представления арифметического выражения из инфиксной формы в постфиксную форму. Алгоритм вычисления значения арифметического выражения, записанного в постфиксной форме. Алгоритм вычисления арифметического выражения, записанного в инфиксной форме, без промежуточной конвертации в постфиксную форму</span>

####  <span style="color:rgb(191, 138, 244)">Префиксная, инфиксная и постфиксная форма арифметического выражения</span>

###### Основные формы арифметических выражений:
1. **Инфиксная форма**: операторы располагаются между операндами (например, `A + B`).
2. **Префиксная форма**: операторы располагаются перед операндами (например, `+ A B`).
3. **Постфиксная форма**: операторы располагаются после операндов (например, `A B +`).

#### <span style="color:rgb(191, 138, 244)">Алгоритм конвертации строкового представления арифметического выражения из инфиксной формы в постфиксную форму</span>

- <span style="color:rgb(237, 125, 164)"> Вход :</span> строка, в которой содержится одно арифметическое выражение
- <span style="color:rgb(237, 125, 164)">Выход :</span> строка, в которой содержится постфиксное выражение
#### Алгоритм

- Использовать **стек** для хранения операторов.
- Пройти по входной строке (инфиксному выражению) символ за символом:
    - Если символ является **операндом**, добавить его к результату.
    - Если символ — **'('**, поместить его в стек.
    - Если символ — **')'**, выталкивать операторы из стека в результат до тех пор, пока не встретится `'('` (которую затем удаляют из стека).
    - Если символ является **оператором**:
        - Удалить из стека в результат все операторы с большим или равным приоритетом.
        - Поместить текущий оператор в стек.
- После обработки всей строки перенести все оставшиеся операторы из стека в результат.
#### Пример

**Инфиксное выражение:**  
`(A+B)*(C+D)/E-F`
**Постфиксное выражение:**  
`AB+CD+*E/F-`

![[Pasted image 20241128130904.png]]

#### Реализация стека на динамическом массиве

```c
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

typedef struct Stack {
    char* data;     // Динамический массив
    int top;        // Индекс верхнего элемента
    int capacity;   // Вместимость стека
} Stack;

// Инициализация стека с начальной вместимостью по умолчанию
errorCode initStack(Stack* stack) {
    stack->capacity = 20;  // Вместимость по умолчанию
    stack->data = (char*)malloc(stack->capacity * sizeof(char));
    if (stack->data == NULL){
	    return MEMORY_ERROR;
    }
    stack->top = -1;
    return OPT_SUCCES;
}

int isFull(Stack* stack) {
    return stack->top == stack->capacity - 1;
}

int isEmpty(Stack* stack) {
    return stack->top == -1;
}

// Увеличение размера стека
errorCode resizeStack(Stack* stack) {
    stack->capacity *= 2;  // Увеличиваем вместимость в 2 раза
    stack->data = (char*)realloc(stack->data, stack->capacity * sizeof(char));
    if (stack->data == NULL){
	    return MEMORY_ERROR;
    }
    return OPT_SUCCES;
}

// Добавление элемента в стек
void push(Stack* stack, char ch) {
    if (isFull(stack)) {
        resizeStack(stack); // Расширяем стек при необходимости
    }
    stack->data[++stack->top] = ch; // Увеличиваем top, добавляем элемент
}

// Удаление верхнего элемента из стека
char pop(Stack* stack) {
    if (!isEmpty(stack)) {
        return stack->data[stack->top--]; // Возвращаем элемент, уменьшаем top
    }
    return '\0';
}

// Получение верхнего элемента без удаления
char peek(Stack* stack) {
    if (!isEmpty(stack)) {
        return stack->data[stack->top]; // Возвращаем верхний элемент
    }
    return '\0';
}

void destroy(Stack* stack) {
    free(stack->data);
    stack->data = NULL;
    stack->top = -1;
    stack->capacity = 0;
    free(stack);
}

// Функция для определения приоритета операторов
int precedence(char op) { 
	if (op == '+' || op == '-') return 1; 
	if (op == '*' || op == '/') return 2; 
	return 0; 
}

// Проверка, является ли символ оператором
int isOperator(char ch) {
    return ch == '+' || ch == '-' || ch == '*' || ch == '/';
}
```
#### Функция перевода

```c
// Конвертация инфиксного выражения в постфиксное
errorCode infixToPostfix(const char* infix, char* postfix) {
    Stack* stack = (Stack*)malloc(sizeof(Stack));
    if (stack == NULL){
	    return MEMORY_ERROR;
    }
    if (initStack(stack) != OPT_SUCCES){
	    free(stack);
	    return MEMORY_ERROR;
    }
    int i = 0, j = 0;
    while (infix[i] != '\0') {
        char ch = infix[i];
        if (isalnum(ch)) {
            postfix[j++] = ch; // Если операнд, добавляем к выходной строке
        } else if (ch == '(') {
            push(stack, ch);
        } else if (ch == ')') {
            while (!isEmpty(stack) && peek(stack) != '(') {
                postfix[j++] = pop(stack);
            }
            pop(stack); // Удаляем '(' из стека
        } else if (isOperator(ch)) {
            while (!isEmpty(stack) && precedence(peek(stack)) >= precedence(ch)) {
                postfix[j++] = pop(stack);
            }
            push(stack, ch);
        }
        i++;
    }

    // Извлекаем оставшиеся операторы из стека
    while (!isEmpty(stack)) {
        postfix[j++] = pop(stack);
    }
    postfix[j] = '\0'; // Завершаем строку

    // Освобождаем память, выделенную под стек
    destroy(stack);
}
```

#### <span style="color:rgb(191, 138, 244)">Алгоритм вычисления значения арифметического выражения, записанного в постфиксной форме</span>

#### Алгоритм:

1. Создаём стек для хранения чисел (операндов).
2. Читаем постфиксное выражение слева направо.
3. Для каждого символа:
    - Если это операнд (число), преобразуем его в число и кладём в стек.
    - Если это оператор (`+`, `-`, `*`, `/`):
        - Извлекаем два верхних числа из стека.
        - Выполняем операцию с этими числами.
        - Результат операции кладём обратно в стек.
4. После обработки всех символов в выражении:
    - В стеке остаётся единственное число, это и есть результат выражения.
#### Функция для вычисления

```c
errorCode evaluatePostfix(const char* expression, double* result) {
    Stack* stack = (Stack*)malloc(sizeof(Stack)); // здесь стек int'ов
    if (stack == NULL){
	    return MEMORY_ERROR;
    }
    if (initStack(stack) != OPT_SUCCES){
	    free(stack);
	    return MEMORY_ERROR;
    }

    for (int i = 0; expression[i] != '\0'; i++) {
        char token = expression[i];

        if (isdigit(token)) {
            // Если операнд, преобразуем его в число и кладём в стек
            push(stack, token - '0');
        } else if (isOperator(ch)) {
            // Если оператор, извлекаем два верхних числа из стека
            double b = pop(stack);
            double a = pop(stack);
            
            // Выполняем соответствующую операцию
            double res;
            switch (token) {
                case '+': res = a + b; break;
                case '-': res = a - b; break;
                case '*': res = a * b; break;
                case '/':
                    if (b == 0) {
                        freeStack(stack);
                        free(stack);
                        return DIVISION_BY_ZERO; // Ошибка: деление на ноль
                    }
                    res = a / b;
                    break;
                default:
                    freeStack(stack);
                    free(stack);
                    return INVALID_OPERATOR; // Ошибка: неизвестный оператор
            }

            // Кладём результат обратно в стек
            push(stack, res);
        }
    }

    // После обработки в стеке должен остаться один элемент
    *result = pop(stack);
    if (!isEmpty(stack)) {
        freeStack(stack);
        free(stack);
        return INVALID_FORMAT; // Ошибка: некорректное выражение
    }

    // Очищаем стек и возвращаем успешный результат
    destroy(stack);
    return OPT_SUCCES;
}
```

#### Пример
##### Вход: `"52+"`
1. **Пошаговый разбор:**
    
    - `5` → Кладём в стек.
    - `2` → Кладём в стек.
    - `+` → Снимаем два элемента (`5` и `2`), результат `7` кладём в стек.
2. **После обработки:**
    
    - В стеке: `7` (всё корректно).
    - Результат: `7`.
#### <span style="color:rgb(191, 138, 244)">Алгоритм вычисления арифметического выражения, записанного в инфиксной форме, без промежуточной конвертации в постфиксную форму</span>

#### Алгоритм:

1. **Два стека**:
    - **Операндов**: Хранит цифры.
    - **Операторов**: Хранит символы операций (`+`, `-`, `*`, `/`, `(`).
2. **Правила обработки**:
    - Если символ — число, кладём его в стек операндов.
    - Если символ — оператор:
        - Пока на вершине стека операторов есть оператор с более высоким или равным приоритетом:
            - Извлекаем оператор из стека операторов.
            - Извлекаем два операнда из стека операндов.
            - Выполняем операцию и кладём результат обратно в стек операндов.
        - Кладём текущий оператор в стек операторов.
    - Если символ — `(`, кладём его в стек операторов.
    - Если символ — `)`, извлекаем операторы из стека операторов и выполняем операции до тех пор, пока не найдём `(`.
3. **После обработки строки**:
    - Когда входное выражение полностью обработано, извлекаем оставшиеся операторы из стека операторов и выполняем соответствующие операции.
4. **Результат**:
    - В стеке операндов остаётся единственное число — это результат.

#### Функция для вычисления

```c
// Выполнение операции
double applyOperation(double a, double b, char op) {
    switch (op) {
        case '+': return a + b;
        case '-': return a - b;
        case '*': return a * b;
        case '/': return a / b;
    }
}

// Вычисление значения инфиксного выражения
errorCode evaluateInfix(const char* expression, double* res) {
	Stack_val* values = (Stack_val*)malloc(sizeof(Stack_val));  // Стек операндов
	Stack_op* operators = (Stack_op*)malloc(sizeof(Stack_op)); // Стек операций
    if (!values || !operators) return MEMORY_ERROR; // не оч, но пойдёт
    if (initStack_val(values) != OPT_SUCCES){
	    free(values);
	    free(operators)
	    return MEMORY_ERROR;
    }else if(initStack_op(operators) != OPT_SUCCES){
	    destroy_val(values);
	    free(operators);
	    return MEMORY_ERROR;
    }
    
    for (int i = 0; expression[i] != '\0'; i++) {
        char token = expression[i];

        // Если это цифра
        if (isdigit(token)) {
            push_val(values, token - '0');
        }
        // Если открывающая скобка
        else if (token == '(') {
            push_op(operators, token);
        }
        // Если закрывающая скобка
        else if (token == ')') {
            char op;
            double a, b;
            while (!isEmpty(operators)) {
                op = pop_op(operators);
                if (op == '(') break;
                b = pop_val(values);
                a = pop_val(values);
                double result = applyOperation(a, b, op);
                push_val(values, result);
            }
        }
        // Если оператор
        else if (isOperator(token)) {
            char op;
            while (!isEmpty(operators)) {
                op = peek_op(operators);
                if (precedence(op) < precedence(token)) break;
                op = pop_op(operators);
                double a, b;
                b = pop_val(values);
                a = pop_val(values);
                double result = applyOperation(a, b, op);
                push_val(values, result);
            }
            push_op(operators, token);
        } else {
            return INVALID_FORMAT;
        }
    }

    // Завершаем все оставшиеся операции
    char op;
    double a, b;
    while (!isEmpty(operators)) {
        op = pop_op(operators);
        b = pop_val(values);
        a = pop_val(values);
        double result = applyOperation(a, b, op);
        push_val(values, result);
    }

    // Результат — единственный элемент в стеке операндов
    *res = pop_val(values);

    // Очищаем память
    destroy_val(values);
    destroy_op(operators);

    return OPT_SUCCES;
}
```

#### Пример

`(3 + 5) * 2`

![[Pasted image 20241129021124.png]]
### <span style="color:rgb(197, 249, 154)">18. Деревья общего вида и операции над ними. Описание структуры элемента дерева общего вида на языке C</span>

Дерево общего вида (general tree) — это структура данных, в которой узел может иметь любое количество дочерних узлов. Для представления такого дерева в C обычно используется структура, которая включает указатель на первый дочерний узел (child) и указатель на следующий узел на том же уровне, то есть на брата/соседа (neighbor).

#### <span style="color:rgb(237, 125, 164)">Структура дерева общего вида</span>

```c
struct node_t {
  double value;
  node_t* child; // указатель на ребёнка
  node_t* neighbor; // указатель на соседа
};
```
#### <span style="color:rgb(237, 125, 164)">Создание узла</span>

```c
node_t* tree_create(double value) {
  node_t* node = (node_t*)malloc(sizeof(node_t));
  if (!node) return NULL;

  node->value = value;
  node->child = NULL;
  node->neighbor = NULL;

  return node;
}
```
- Сложность О(1)
#### <span style="color:rgb(237, 125, 164)">Вставка узла в дерево</span>

Добавление нового узла происходит в зависимости от пути (`path`):

- Если `path` содержит `'c'`, то переход идет к дочернему узлу.
- Если `path` содержит `'n'`, то переход идет к соседнему узлу.
- Если `path` заканчивается (`*path != '\0' && *(path + 1) == '\0'`), создается новый узел, который либо становится первым дочерним узлом (`'c'`), либо соседом (`'n'`) текущего узла.

1) Если последний символ `'c'`, создается новый дочерний узел: новый узел становится первым дочерним узлом, а предыдущие дети "сдвигаются" на одну позицию вниз.
2) Если последний символ `'n'`, создается новый сосед: новый узел становится первым соседом текущего узла, а предыдущие соседи "сдвигаются".
3) Если текущий символ не является последним, функция рекурсивно переходит к соответствующему потомку (`child`) или соседу (`neighbor`).
```c
bool tree_add(node_t* node, double value, char* path) {
  if (node == NULL)
    return false;

  if (*path != '\0' && *(path + 1) == '\0') {
    if (*path != 'c' && *path != 'n')
      return false;

    node_t* new_node = tree_create(value);
    
    if (*path == 'c') {
      new_node->child = node->child;
      node->child = new_node;
    } else if (*path == 'n') {
      new_node->neighbor = node->neighbor;
      node->neighbor = new_node;
    }

    return true;
  } else if (*path == 'c')
    return tree_add(node->child, value, path + 1);
  else if (*path == 'n')
    return tree_add(node->neighbor, value, path + 1);

  return false;
}
```
- Сложность О(L), где L — длина пути до места вставки
#### <span style="color:rgb(237, 125, 164)">Удаление дерева общего вида</span>

- Рекурсивное удаление: Сначала рекурсивно удаляются дочерние узлы, затем — соседи. 
- Освобождение памяти: После уничтожения всех дочерних и соседних узлов освобождается текущий узел с помощью `free(node)`.
```c
void tree_destroy(node_t* node) {
  if (node->child != NULL)
    tree_destroy(node->child);
  if (node->neighbor != NULL)
    tree_destroy(node->neighbor);
  free(node);
}
```
- Сложность О(n), где n — количество узлов
#### <span style="color:rgb(237, 125, 164)">Печать дерева общего вида</span>

Функция **`tree_print`** реализует **DFS (Depth-First Search, обход в глубину)** алгоритм для дерева. 

-  Сначала функция переходит к **дочернему узлу** (`child`), углубляясь вниз по иерархии.
- Затем, после обработки потомков, переходит к **соседним узлам** (`neighbor`) на текущем уровне.
-  Посещение каждого узла ровно один раз

```c
void tree_print(node_t* root, int depth) {
	if (node == NULL) return;
	for (int i = 0; i < depth; i++) {
	    printf("\t");
	}
	printf("%lf\n", root->value);
	
	tree_print(root->child, depth + 1);
    tree_print(root->neighbor, depth);
}
```

![[Pasted image 20241127001322.png]]
- Сложность О(n), где n — количество узлов
#### <span style="color:rgb(237, 125, 164)">Удаление узла</span>

-  Функция обходит дерево по указанному пути (`path`) и находит узел, который нужно удалить.
- Возвращает указатель на удаляемый узел для дальнейшего освобождения памяти.

1) Конец пути (`'\0'`) означает, что текущий узел `node` — это тот, который нужно удалить.
2) Если узел `node` — это **сосед** предыдущего узла (`prev->neighbor`): узел удаляется, а соседние узлы подключаются друг к другу.
3) Если узел `node` — это **ребенок** предыдущего узла (`prev->child`):  указатель на удаляемый узел заменяется на его соседа, чтобы сохранить связь дерева.
4) Если узел корневой (`prev == NULL`), удаление запрещено.

```c
node_t* tree_remove(node_t* node, node_t* prev, char* path) {
	if (node == NULL)
		return NULL; // Если узел, указанный в пути, не найден, возвращается NULL

	if (*path == '\0') {
		if (prev != NULL) {
			if (prev->neighbor == node){
				prev->neighbor = node->neighbor;
			}else if (prev->child == node){
				prev->child = node->neighbor;
			}
			return node;
		}
	}else if (*path == 'c'){
	    return tree_remove_helper(node->child, node, path + 1);
	}else if (*path == 'n'){
	    return tree_remove_helper(node->neighbor, node, path + 1);
	}
	return NULL;
}
```
- Сложность О(L), где L — длина пути до места удаления
### <span style="color:rgb(197, 249, 154)">19. Отношение порядка на пространстве элементов. Кастомизация операции отношения порядка для заданного контекста в языке C. Быстрая сортировка и функция qsort. Алгоритм дихотомического поиска, его алгоритмическая сложность</span>

#### <span style="color:rgb(191, 138, 244)">Кастомизация операции отношения порядка для заданного контекста в языке C</span>

==Отношение порядка== — это способ сравнения двух элементов, определяющий, какой из них "меньше", "равен" или "больше". В C мы можем кастомизировать отношения порядка, задавая функции сравнения для работы с различными алгоритмами сортировки, включая стандартную функцию `qsort` (quick sort).

Функция сравнения принимает два указателя на элементы и возвращает:
- Отрицательное значение, если первый элемент "меньше" второго.
- Ноль, если элементы равны.
- Положительное значение, если первый элемент "больше" второго.
Такая функция называется компаратором. 

==Компаратор== — это функция, используемая для определения порядка двух элементов. Его основная задача — реализовать **отношение порядка** между элементами в контексте конкретной задачи, например, сортировки (программная реализация логики, определяющей, как сравниваются элементы).

Отношение порядка определяет, как элементы сравниваются друг с другом. Это может быть:
- **Строгий порядок**: a<b  или a>b, например, для чисел.
- **Нестрогий порядок**: a≤b  или a≥b, например, для чисел в отсортированном массиве.
#### <span style="color:rgb(237, 125, 164)">Пример компаратора</span>

Например, пусть существует массив структур с данными о студентах, где тип элемента «студент» выглядит следующим образом:

```c
struct Student{  
   int age, marks;  
   char name[20];  
};
```

Нам нужно отсортировать студентов по оценкам в порядке возрастания. Функция сравнения будет выглядеть так:

```c
int comparator(const void* p, const void* q){  
   int l = ((struct Student*)p)->marks;  
   int r = ((struct Student*)q)->marks;  
   return (l - r);  
}
```

### <span style="color:rgb(191, 138, 244)">Быстрая сортировка</span>

###### <span style="color:rgb(124, 238, 219)">Алгоритм быстрой сортировки (сортировки Хоара):</span>
1. **Выбор опорного элемента (pivot)**: Из массива выбирается один элемент, называемый опорным (pivot). Опорный элемент может быть выбран разными способами, например, первым элементом массива, последним элементом, случайным элементом или медианой
2. **Разделение (partition)**: Массив перестраивается таким образом, чтобы все элементы, меньшие опорного, оказались перед ним, а все элементы, большие опорного, — после него.
3. **Рекурсивная сортировка**: Подмассивы, полученные после разделения, сортируются рекурсивно тем же способом.
###### <span style="color:rgb(124, 238, 219)">Сложность алгоритма:</span>
- **Лучший случай**: O(nlogn), если массив разделяется на примерно равные части.
- **Худший случай**: O(n^2), если массив уже отсортирован или элементы разделяются неравномерно или все элементы равны.
- **Средний случай**: O(nlogn).

```c
#include <stdio.h>

// Функция для обмена элементов
void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

// Разделяющая функция (разделяет массив на две части)
int partition(int arr[], int low, int high) {
    int pivot = arr[high]; // Выбираем последний элемент как опорный
    int i = low - 1;       // Индекс меньшего элемента

    for (int j = low; j < high; j++) {
        // Если текущий элемент меньше или равен опорному
        if (arr[j] <= pivot) {
            i++; // Увеличиваем индекс меньшего элемента
            swap(&arr[i], &arr[j]);
        }
    }
    // Размещаем опорный элемент на правильной позиции
    swap(&arr[i + 1], &arr[high]);
    return i + 1; // Возвращаем индекс опорного элемента
}

// Рекурсивная функция быстрой сортировки
void quickSort(int arr[], int low, int high) {
    if (low < high) {
        // Разделяем массив и получаем индекс опорного элемента
        int pi = partition(arr, low, high);

        // Рекурсивно сортируем элементы до и после опорного
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}
```

#### <span style="color:rgb(191, 138, 244)">Функция qsort</span>

Функция `qsort`, предоставляемая библиотекой `stdlib.h`, реализует алгоритм быстрой сортировки. Она работает с любыми типами данных, благодаря кастомизации отношения порядка через указатель на функцию сравнения.

```c
void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void *));
```

- `base` — указатель на массив.
- `nitems` — количество элементов в массиве.
- `size` — размер одного элемента массива.
- `compar` — указатель на функцию сравнения.
#### Пример

```c
#include <stdio.h>
#include <stdlib.h>

// Функция сравнения для целых чисел
int compareInt(const void *a, const void *b) {
    return (*(int *)a - *(int *)b);
}

int main() {
    int arr[] = {3, 1, 4, 1, 5, 9, 2, 6, 5};
    size_t n = sizeof(arr) / sizeof(arr[0]);

    qsort(arr, n, sizeof(int), compareInt);

    printf("Отсортированный массив: ");
    for (size_t i = 0; i < n; i++) {
        printf("%d ", arr[i]);
    }
    printf("\n");
}
```
### <span style="color:rgb(197, 249, 154)">20. Бинарные деревья поиска. Создание и удаление бинарного дерева. Операция поиска элемента в дереве, её связь с дихотомическим (бинарным) поиском. Операции префиксного, инфиксного и постфиксного обхода бинарного дерева, вставки/удаления элемента. Вычислительные сложности и реализация вышеописанных операций на языке C</span>

==**Бинарное дерево поиска (BST)**== — это структура данных в виде двоичного дерева, в котором каждый узел имеет значение и два указателя на потомков: левого и правого. Основная идея бинарного дерева поиска — поддержание порядка элементов, что делает операции поиска и вставки эффективными. Нелинейная структура данных.
==**Основное свойство**== - все значения в левом поддереве узла меньше его текущего значения, все значения в правом поддереве узла больше его текущего значения.
**Операции**:
- поиск
- вставка
- удаление
>[!Note]
>Если в двоичном дереве N узлов, то пустых узлов N + 1
#### <span style="color:rgb(191, 138, 244)">Структура узла бинарного дерева</span>

```c
struct Node {
	int data;
	struct Node* left;
	struct Node* right; 
};
```
- Значение узла 
- Указатель на левый дочерний узел 
- Указатель на правый дочерний узел

#### <span style="color:rgb(191, 138, 244)">Создание узла бинарного дерева</span>

```c
struct Node* create(int data){
	struct Node* root = (struct Node*)malloc(sizeof(struct Node));
	if (root == NULL){
		return NULL;
    }
	root->data = data;
	root->left = NULL;
	root->right = NULL;
	return root;
}
```

<span style="color:rgb(237, 125, 164)">Ассимптотическая сложность создания отдельного узла в бинарном дереве составляет O(1) (константное время)</span>
#### <span style="color:rgb(191, 138, 244)">Удаление бинарного дерева (post-order)</span>

```c
void destroy(struct Node* root){
    if (root == NULL){
        return;
    }
    destroy(root->left);
    destroy(root->right);
    free(root);
}
```

<span style="color:rgb(237, 125, 164)">Ассимптотическая сложность рекурсивного удаления бинарного дерева составляет O(n), где n — количество узлов в дереве</span>
#### <span style="color:rgb(191, 138, 244)">Вставка элемента</span>

```c
struct Node* insert(struct Node* root, int num){
    if (root == NULL){
        return create(num);
    }
    if (root->data > num){
        root->left = insert(root->left, num);
    }else if (root->data < num){
        root->right = insert(root->right, num);
    }
    return  root;
}
```

- <span style="color:rgb(237, 125, 164)">Сбалансированное дерево: O(log⁡n)</span>
- **<span style="color:rgb(237, 125, 164)">Несбалансированное дерево</span><span style="color:rgb(237, 125, 164)">: O(n)</span>

#### <span style="color:rgb(191, 138, 244)">Удаление элемента</span>

###### 3 ситуации:
- удаляемый узел не имеет детей (просто удаляем этот концевой узел)
- удаляемый узел имеет одного ребёнка (заменяем указатель родительского узла на на его единственного ребёнка и удаляем родительский узел)
- удаляемый узел имеет два ребёнка (в правом поддереве родительского узла ищем узел с минимальным значением; заменяем значение удаляемого узла значением найденного узла и удаляем найденный узел)
```c
struct Node* removeNode(struct Node* root, int num){
    if (root == NULL){
        return NULL;
    }
    if (root->data > num){
        root->left = removeNode(root->left, num);
    }else if (root->data < num){
        root->right = removeNode(root->right, num);
    }else if (root->data == num){
        if (root->left == NULL && root->right == NULL){
            free(root);
            return NULL;
        }
        
        if (root->left == NULL){
            struct Node* tmp = root->right;
            free(root);
            return tmp;
        }else if (root->right == NULL){
            struct Node* tmp = root->left;
            free(root);
            return tmp;
        }
        
        struct Node* tmp = root->right;
        while (tmp->left != NULL){
            tmp = tmp->left;
        }
        root->data = tmp->data;
        root->right = removeNode(root->right, tmp->data);
    }
    return root;
}
```

![[Pasted image 20241110165756.png]]
![[Pasted image 20241205192139.png]]
![[Pasted image 20241205192236.png]]

<span style="color:rgb(237, 125, 164)">Алгоритм удаления имеет асимптотическую сложность O(h), где h — высота дерева. В сбалансированном дереве это будет O(log⁡n), а в несбалансированном — O(n).</span>

- **Сбалансированное дерево**: O(log⁡n) — каждый шаг удаления пропорционален высоте дерева, и все операции поддерживают дерево сбалансированным.
- **Несбалансированное дерево**: O(n) — если дерево вырождается в линейную структуру, поиск и удаление могут потребовать посещения всех n узлов.

#### <span style="color:rgb(191, 138, 244)">Печать дерева (reverse in-order traversal)</span>

```c
void printTree(struct Node* root, int h){
    if (root == NULL){
        return;
    }
    printTree(root->right, h + 1);
    for (int i = 0; i < h; i++){
        printf("\t");
    }
    printf("%d\n", root->data);
    printTree(root->left, h + 1);
}
```

![[Pasted image 20241109234729.png]]
#### <span style="color:rgb(191, 138, 244)">Операция поиска элемента в дереве, её связь с дихотомическим (бинарным) поиском</span>

Поиск элемента в бинарном дереве и бинарный (дихотомический) поиск — два алгоритма, основанных на принципе деления промежутка пополам, что позволяет эффективно находить нужный элемент за логарифмическое время.
###### Поиск в бинарном дереве

1. **Алгоритм**: Поиск элемента в бинарном дереве начинается с корневого узла и сравнивает искомое значение с текущим узлом. Если значение меньше текущего узла, переходят к левому поддереву, если больше — к правому. Процесс повторяется до тех пор, пока не найден нужный элемент или не достигнут конец дерева.
2. **Сложность**: В сбалансированном бинарном дереве поиск занимает O(log⁡n) времени, поскольку на каждом шаге отсеивается половина возможных узлов. В несбалансированном дереве сложность может достигать O(n), так как дерево может выродиться в линейную структуру.

```c
struct Node* search(struct Node* root, int num){
    if (root == NULL){
        return root;
    }
    if (root->data > num){
        return search(root->left, num);
    }else if (root->data < num){
        return search(root->right, num);
    }else if (root->data == num){
        return root;
    }
}
```

- <span style="color:rgb(237, 125, 164)">Сбалансированное дерево: O(log⁡n)</span>
- **<span style="color:rgb(237, 125, 164)">Несбалансированное дерево</span><span style="color:rgb(237, 125, 164)">: O(n)</span>
###### Связь с дихотомическим (бинарным) поиском

1. **Алгоритм**: Бинарный поиск в отсортированном массиве также разделяет список пополам. На каждом шаге сравнивается искомое значение с элементом в середине массива. Если значение меньше среднего элемента, дальнейший поиск продолжается в левой половине массива, если больше — в правой.
2. **Сложность**: Бинарный поиск занимает O(log⁡n) времени, так как количество элементов для проверки уменьшается вдвое с каждым шагом.

- **Сходства**: Оба алгоритма работают по принципу деления и сокращения возможных вариантов поиска, что делает их эффективными для структур с определённым порядком элементов. Оба алгоритма имеют временную сложность O(log⁡n) в оптимальных случаях.
#### <span style="color:rgb(191, 138, 244)">Алгоритмы префиксного, инфиксного и постфиксного обхода бинарного дерева</span>

###### 1) **Preorder (префиксный обход)**: Посещаем корень, затем левое поддерево и правое поддерево (КЛП)

![[Pasted image 20241110154725.png]]

```c
void preorderTraversal(struct Node* root) {
    if (root == NULL){
        return;
    }
    printf("%d ", root->data);  
    preorderTraversal(root->left);
    preorderTraversal(root->right);
}
```

###### 2) **Inorder (инфиксный обход)**: Посещаем левое поддерево, корень, затем правое поддерево (ЛКП)

![[Pasted image 20241110155527.png]]

```c
void inorderTraversal(struct Node* root) {
    if (root == NULL){
        return;
    }
    inorderTraversal(root->left);
    printf("%d ", root->data);  
    inorderTraversal(root->right);
}
```
###### 3) **Postorder (постфиксный обход)**: Посещаем левое поддерево, правое поддерево и только затем корень (ЛПК)

![[Pasted image 20241110160129.png]]

```c
void postorderTraversal(struct Node* root) {
    if (root == NULL){
        return;
    }
    postorderTraversal(root->left);
    postorderTraversal(root->right);
    printf("%d ", root->data);  
}
```

<span style="color:rgb(237, 125, 164)">Ассимптотическая сложность всех трех обходов (префиксного, инфиксного и постфиксного) бинарного дерева составляет O(n), где n — количество узлов в дереве</span> 

### <span style="color:rgb(197, 249, 154)">21.  Декартово дерево. Создание и удаление декартова дерева. Операция поиска элемента в декартовом дереве, её связь с дихотомическим (бинарным) поиском. Операции вставки/удаления элемента. Вычислительные сложности и реализация вышеописанных операций на языке C</span>

#### <span style="color:rgb(191, 138, 244)">Декартово дерево</span>

==Декартово дерево== — это структура данных, которая совмещает свойства бинарного дерева поиска (BST) и свойства кучи (heap). Оно строится на основе двух ключей:

1. **Ключ поиска**: используется для упорядочивания элементов, как в бинарном дереве поиска.
2. **Приоритет**: каждая вершина имеет случайно назначаемый приоритет, что обеспечивает балансировку дерева. Приоритет подчиняется свойствам кучи (для всех потомков вершины приоритет меньше, чем у нее самой).

Более строго, это бинарное дерево, в узлах которого хранятся пары (x,y), где x — это ключ, а y — это приоритет. Также оно является двоичным деревом поиска по x и пирамидой по y.
#### Свойства декартова дерева:

1. <span style="color:rgb(124, 238, 219)">По ключам поддерживается структура бинарного дерева поиска</span> (то есть для любого ключа все ключи в левом поддереве меньше ключа текущего узла и все ключи в правом поддереве больше ключа текущего узла. Таким образом, поиск основан только на ключах и выполняется как в бинарном дереве поиска. ==**Приоритеты при этом не влияют на логику поиска**==)
2. <span style="color:rgb(124, 238, 219)">По приоритетам соблюдается свойство кучи</span> (то есть на вершине всегда самый приоритетный элемент)

#### <span style="color:rgb(191, 138, 244)">Структура узла декартова дерева</span>

```c
typedef struct Node {
    int key, priority; // значение ключа и приоритета
    struct Node *left, *right; // указатели на левого и правого потомка узла
} Node;
```
#### <span style="color:rgb(191, 138, 244)">Создание узла декартова дерева</span>

```c
Node* createNode(int key) {
    Node* node = (Node*)malloc(sizeof(Node));
    if (!node) return NULL;
    node->key = key;
    node->priority = rand();
    node->left = node->right = NULL;
    return node;
}
```

#### <span style="color:rgb(191, 138, 244)">Создание декартова дерева из массива Node</span>

```c
// Поиск элемента с наибольшим приоритетом в массиве
int findMaxPriorityIndex(Node* nodes, int start, int end) {
    int maxIndex = start;
    for (int i = start + 1; i <= end; i++) {
        if (nodes[i].priority > nodes[maxIndex].priority) {
            maxIndex = i;
        }
    }
    return maxIndex;
}

// Рекурсивное построение дерева
Node* buildTreapRecursive(Node* nodes, int start, int end) {
    if (start > end) return NULL;

    // Найти индекс элемента с максимальным приоритетом
    int maxIndex = findMaxPriorityIndex(nodes, start, end);

    // Создать корневой узел
    Node* root = &nodes[maxIndex];

    // Построить левое и правое поддеревья:
    // 1. Узлы с ключами меньшими, чем ключ текущего корня
    root->left = buildTreapRecursive(nodes, start, maxIndex - 1);
    // 2. Узлы с ключами большими, чем ключ текущего корня
    root->right = buildTreapRecursive(nodes, maxIndex + 1, end);

    return root;
}

// Функция построения дерева из массива
Node* buildTreap(Node* nodes, int n) {
    return buildTreapRecursive(nodes, 0, n - 1);
}
```

**Алгоритм:**

1. **Шаг 1:** Если текущий диапазон массива пустой (начальный индекс больше конечного), возвращаем `NULL` (пустое дерево).
    
2. **Шаг 2:** Найти узел с максимальным приоритетом в текущем диапазоне массива.
    
    - Этот узел становится корнем текущего поддерева.
3. **Шаг 3:** Разделить оставшиеся узлы:
    
    - **Левое поддерево:** Узлы с индексами от начала диапазона до индекса узла с максимальным приоритетом минус один.
    - **Правое поддерево:** Узлы с индексами от индекса узла с максимальным приоритетом плюс один до конца диапазона.
4. **Шаг 4:** Рекурсивно построить:
    
    - Левое поддерево для левого диапазона.
    - Правое поддерево для правого диапазона.
5. **Шаг 5:** Установить указатели `left` и `right` у текущего корня на построенные левое и правое поддеревья.
    
6. **Шаг 6:** Вернуть текущий корень дерева.
#### Пример:

![[Pasted image 20241130221259.png]]
![[Pasted image 20241130221344.png]]
![[Pasted image 20241130221436.png]]
![[Pasted image 20241130221542.png]]
![[Pasted image 20241130221624.png]]
![[Pasted image 20241130221657.png]]

#### <span style="color:rgb(191, 138, 244)">Создание декартова дерева из массива Node с использованием merge</span>

```c
int compareKeys(const void* a, const void* b) {
    Node* nodeA = *(Node**)a;
    Node* nodeB = *(Node**)b;
    return nodeA->key - nodeB->key;
}


Node* createTreap(Node** nodes, int n) {
    // Сортируем массив узлов по ключам
    qsort(nodes, n, sizeof(Node*), compareKeys);

    Node* root = NULL;

    // Постепенно добавляем каждый узел в дерево, используя merge
    for (int i = 0; i < n; ++i) {
        root = merge(root, nodes[i]);
    }
    return root;
}
```
#### <span style="color:rgb(191, 138, 244)">Merge двух деревьев</span>

Важное условие: все ключи в левом дереве должны быть строго меньше каждого из ключей в правом

```c
Node* merge(Node* a, Node* b) {
    if (!a || !b)
        return a ? a : b;
    if (a->priority > b->priority) {
        a->right = merge(a->right, b);
        return a;
    } else {
        b->left = merge(a, b->left);
        return b;
    }
}
```

#### Алгоритм:

1) Если одно из деревьев пустое (`a == NULL` или `b == NULL`), возвращается другое дерево. Это завершает работу рекурсии, когда одно из деревьев полностью обработано
2) Если приоритет корня левой кучи больше, чем приоритет корня правой кучи:
	- Корень левой кучи становится корнем результирующего дерева
	- Объединяем **правое поддерево** левой кучи с деревом правой кучи
3) Если приоритет корня правой кучи больше, чем приоритет корня левой кучи:
	- Корень правой кучи становится корнем результирующего дерева.
	- Объединяем дерево левой кучи с **левым поддеревом** правой кучи
4)  Каждый вызов рекурсивно уменьшает размер дерева, объединяя поддеревья до тех пор, пока одно из деревьев не станет пустым. В результате дерево с корнем большего приоритета становится родительским, а меньший приоритет распределяется в его поддеревья.

![[Pasted image 20241201044709.png]]
![[Pasted image 20241201044748.png]]
![[Pasted image 20241201044822.png]]
![[Pasted image 20241201044905.png]]
![[Pasted image 20241201044941.png]]
![[Pasted image 20241201045013.png]]

#### <span style="color:rgb(191, 138, 244)">Split декартова дерева</span>

```c
void split(Node* n, int key, Node** a, Node** b) {
    if (!root) {
        *a = *b = NULL;
        return;
    } else if (n->key < key) {
        split(n->right, key, &(n->right), b);
        *a = n;
    } else {
        split(n->left, key, a, &(n->left));
        *b = n;
    }
}
```

Функция `split` используется для разделения декартова дерева на два поддерева по заданному ключу `key`. После выполнения функции:

- Все узлы, ключи которых **меньше** `key`, окажутся в левом поддереве.
- Все узлы, ключи которых **больше или равны** `key`, окажутся в правом поддереве.
#### Алгоритм:

В дереве А будут хранится все ключи, меньшие заданного, в дереве В - все остальные
1) Если дерево пустое, то есть `root == NULL`, присваиваем `NULL` указателям на левое и правое поддерево
2) Сравниваем ключ корня с заданным ключом
3) Если заданный ключ больше ключа корня, то корень и его левое поддерево попадают в А. Вызываем `split` для правого поддерева 
4) Если заданный ключ меньше ключа корня, то корень и его правое поддерево попадают в В. Вызываем `split` для левого поддерева

![[Pasted image 20241201045115.png]]
![[Pasted image 20241201045154.png]]
![[Pasted image 20241201045230.png]]
![[Pasted image 20241201045257.png]]
![[Pasted image 20241201045323.png]]
![[Pasted image 20241201045347.png]]

#### <span style="color:rgb(191, 138, 244)">Вставка элемента</span>

```c
Node* insert(Node* root, int key) {
    Node* newNode = createNode(key);
    if (!root)
        return newNode;
    Node *less, *greater;
    split(root, key, &less, &greater);
    less = merge(less, newNode);
    return merge(less, greater);
}
```

Функция `insert` добавляет новый узел с заданным ключом `key` в декартово дерево. Она делает это, сохраняя свойства дерева:

- Узлы в левом поддереве имеют ключи меньше, чем ключ текущего узла.
- Узлы в правом поддереве имеют ключи больше, чем ключ текущего узла.
- Приоритеты узлов формируют структуру кучи.
#### Алгоритм:

1) Сначала создается новый узел `newNode` с указанным ключом `key`. Приоритет узла обычно задается случайно
2) Если дерево пустое (`root == NULL`), то новый узел становится корнем
3) Мы не знаем, как новый ключ будет соотносится с ключами дерева, поэтому для начала необходимо сделать операцию `split` по заданному ключу
4) Тогда в `less` все ключи будут меньше заданного, а в `greater` - больше или равны
5) Затем делаем `merge` дерева `less` и узла `newNode`
6) Далее `merge` результата с деревом `greater`

#### <span style="color:rgb(191, 138, 244)">Поиск элемента</span>

#### Описание алгоритма:

Поиск элемента в декартовом дереве аналогичен процессу бинарного поиска в бинарном дереве поиска (BST). Он основывается на сравнении ключей узлов и следовании по соответствующему поддереву.

1. **Сравнение с корнем:**
    - Если ключ текущего узла совпадает с искомым ключом, элемент найден.
    - Если искомый ключ меньше ключа текущего узла, переходим в левое поддерево.
    - Если искомый ключ больше ключа текущего узла, переходим в правое поддерево.
    
2. **Рекурсия или итерация:**
    - Рекурсивно или итеративно повторяем шаги, пока не найдем элемент или не достигнем конца дерева (узел `NULL`).

```c
Node* search(Node* root, int key) {
    while (root) { // Пока текущий узел не NULL
        if (root->key == key) {
            return root; // Найден узел с искомым ключом
        } else if (key < root->key) {
            root = root->left; // Переход в левое поддерево
        } else {
            root = root->right; // Переход в правое поддерево
        }
    }
    return NULL; // Если дошли до конца дерева, элемент не найден
}
```

#### <span style="color:rgb(191, 138, 244)">Удаление элемента</span>

```c
Node* erase(Node* root, int key) {
    if (!root) return NULL;

    Node *less, *greater, *middle;
    split(root, key, &less, &greater);         
    split(greater, key + 1, &middle, &greater); 

    if (middle) free(middle);
    return merge(less, greater);
}
```

#### Алгоритм:

1) Если дерево пустое, ничего не нужно удалять, возвращаем `NULL`
2) Разделяем дерево на два поддерева:
	- **Левое поддерево** будет содержать все узлы с ключами меньшими, чем ключ удаляемого узла (`key`).
	- **Правое поддерево** будет содержать все узлы с ключами большими или равными удаляемому ключу (`key`).
3) Ещё раз разделяем правое поддерево:
	- **Среднее поддерево** содержит только узлы с ключами, равными удаляемому ключу (`key`).
	- **Новое правое поддерево** будет содержать узлы с ключами большими, чем ключ удаляемого узла.
4) Указатель на удаляемый узел освобождается из памяти
5) Левое и правое поддеревья объединяются, чтобы восстановить структуру декартового дерева
#### <span style="color:rgb(191, 138, 244)">Уничтожение дерева</span>

```c
void destroyTree(Node* root) {
    if (root == NULL) return; 
    destroyTree(root->left);
    destroyTree(root->right);
    free(root);
}
```

![[Pasted image 20241201044327.png]]
### <span style="color:rgb(197, 249, 154)">22. Приоритетные очереди. Бинарная приоритетная очередь, её реализация на базе структуры данных вида динамический массив. Операции вставки элемента, поиска минимума/максимума, удаления минимума/максимума, слияния с разрушением и без разрушения исходных бинарных приоритетных очередей; их вычислительные сложности и реализация на языке C</span>

#### <span style="color:rgb(191, 138, 244)">Приоритетные очереди. Бинарная приоритетная очередь</span>

==Приоритетная очередь== — это структура данных, где каждому элементу присваивается приоритет, и операции выполняются в зависимости от приоритетов (обычно минимум или максимум).

==Бинарная куча== (binary heap) — это бинарное дерево, удовлетворяющее двум свойствам:

1. **Свойство кучи (heap property):** Для минимальной кучи значение любого узла меньше или равно значений его потомков; для максимальной — больше или равно.
2. **Свойство полной структуры:** Все уровни дерева заполнены, кроме, возможно, последнего, который заполняется слева направо.

Для реализации на массиве индексация начинается с 0. Пусть текущий узел имеет индекс `i`, тогда:
- Левый потомок: `2i+1`
- Правый потомок: `2i+2`
- Родитель: `⌊(i−1)/2⌋` // округляем вниз
#### <span style="color:rgb(191, 138, 244)">Структура для бинарной кучи</span>

```c
typedef struct {
    int *data;
    int size;
    int capacity;
} BinaryHeap;
```

#### <span style="color:rgb(191, 138, 244)">Создание кучи</span>

```c
BinaryHeap* createHeap(int capacity) {
    BinaryHeap* heap = (BinaryHeap*)malloc(sizeof(BinaryHeap));
    heap->data = (int*)malloc(capacity * sizeof(int));
    heap->size = 0;
    heap->capacity = capacity;
    return heap;
}
```

#### <span style="color:rgb(191, 138, 244)">Уничтожение кучи</span>

```c
void destroyHeap(BinaryHeap* heap) {
    free(heap->data);
    free(heap);
}
```

#### <span style="color:rgb(191, 138, 244)">Увеличение ёмкости</span>

```c
void resizeHeap(BinaryHeap* heap) {
    heap->capacity *= 2;
    heap->data = (int*)realloc(heap->data, heap->capacity * sizeof(int));
}
```

#### <span style="color:rgb(191, 138, 244)">Просеивание вверх для минимальной кучи и вставка</span>

```c
void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

void siftUp(BinaryHeap* heap, int index) {
    while (index > 0) {
        int parent = (index - 1) / 2;
        if (heap->data[parent] <= heap->data[index])
            break;
        swap(&heap->data[parent], &heap->data[index]);
        index = parent;
    }
}

void insert(BinaryHeap* heap, int value) {
    if (heap->size == heap->capacity)
        resizeHeap(heap);
    heap->data[heap->size] = value; // вставляем новый элемент с индексом size
    siftUp(heap, heap->size);
    heap->size++;
}
```

![[Pasted image 20241130005232.png]]

#### <span style="color:rgb(191, 138, 244)">Просеивание вниз для минимальной кучи и удаление</span>

```c
void siftDown(BinaryHeap* heap, int index) {
    while (2 * index + 1 < heap->size) {
        int left = 2 * index + 1;
        int right = 2 * index + 2;
        int smallest = left;

        if (right < heap->size && heap->data[right] < heap->data[left])
            smallest = right;

        if (heap->data[index] <= heap->data[smallest])
            break;

        swap(&heap->data[index], &heap->data[smallest]);
        index = smallest;
    }
}

int remove(BinaryHeap* heap) {
    if (heap->size == 0) {
        printf("Heap is empty!\n");
        return -1;
    }
    int min = heap->data[0]; 
    heap->data[0] = heap->data[--heap->size]; // последний элемент кучи в корень
    siftDown(heap, 0); // просеиваем, пока не установится правильный порядок
    return min;
}
```

#### Пояснение:

-  `2 * index + 1`: индекс левого потомка
- `heap->size`: размер кучи. Если индекс левого потомка меньше размера кучи, значит, элемент ещё имеет детей, и нужно проверить их значения
- определяем индексы левого и правого потомков текущего узла
- `smallest`: предполагаем, что наименьший элемент находится у левого потомка (пока не проверили правого)
- если правый потомок существует (`right < heap->size`) и его значение меньше значения левого потомка (`heap->data[right] < heap->data[left]`), то обновляем `smallest`, чтобы указать на правого потомка
- если текущий элемент меньше или равен меньшему из двух потомков, то дальнейшее перемещение вниз не требуется, цикл завершается
- меняем местами текущий элемент и меньшего из потомков с помощью функции `swap`, чтобы переместить текущий элемент вниз
- `index = smallest` : обновляем индекс, чтобы продолжить процесс перемещения вниз, начиная с позиции, на которую только что переместили текущий элемент

![[Pasted image 20241130013634.png]]

#### <span style="color:rgb(191, 138, 244)">Поиск минимума</span>

```c
int getMin(BinaryHeap* heap) {
    if (heap->size == 0) {
        printf("Heap is empty!\n");
        return -1;
    }
    return heap->data[0];
}
```

-  В минимальной куче минимальный элемент всегда находится в корне, который хранится в `heap->data[0]`

#### <span style="color:rgb(191, 138, 244)">Слияние двух куч с разрушением</span>

```c
// Перестройка кучи (Heapify)
void heapify(BinaryHeap* heap) {
    for (int i = (heap->size / 2) - 1; i >= 0; i--) {
        siftDown(heap, i);
    }
}

// Слияние двух куч с разрушением
BinaryHeap* mergeHeaps(BinaryHeap* heap1, BinaryHeap* heap2) {
    // Создание новой кучи
    int newCapacity = heap1->size + heap2->size;
    BinaryHeap* mergedHeap = createHeap(newCapacity);

    // Копирование элементов из первой кучи
    for (int i = 0; i < heap1->size; i++) {
        mergedHeap->data[mergedHeap->size++] = heap1->data[i];
    }

    // Копирование элементов из второй кучи
    for (int i = 0; i < heap2->size; i++) {
        mergedHeap->data[mergedHeap->size++] = heap2->data[i];
    }

    // Перестройка кучи
    heapify(mergedHeap);

    // Освобождение памяти старых куч
    destroyHeap(heap1);
    destroyHeap(heap2);

    return mergedHeap;
}
```
#### Пояснение:

1. **Объединение массивов:**
    - Копируем элементы из обеих куч в массив новой кучи
2. **Heapify:**
    - Вызываем функцию `heapify` на новой куче. Она перестраивает массив в минимальную кучу, начиная с последнего узла, у которого есть потомки (перемещаем узел вниз по дереву до тех пор, пока свойство кучи не будет выполнено)
3. **Очистка старых куч:**
    - Освобождаем память, занятую старыми кучами (`freeHeap`)

#### <span style="color:rgb(191, 138, 244)">Слияние двух куч без разрушения</span>

```c
// Слияние двух куч без разрушения
BinaryHeap* mergeHeaps(BinaryHeap* heap1, BinaryHeap* heap2) {
    // Создание новой кучи с достаточной ёмкостью
    BinaryHeap* mergedHeap = createHeap(heap1->size + heap2->size);

    // Копирование элементов первой кучи в новую с помощью вставки
    for (int i = 0; i < heap1->size; i++) {
        insert(mergedHeap, heap1->data[i]);
    }

    // Копирование элементов второй кучи в новую с помощью вставки
    for (int i = 0; i < heap2->size; i++) {
        insert(mergedHeap, heap2->data[i]);
    }

    return mergedHeap;
}
```

#### Пояснение:

1. **Создание новой кучи:**
    - Новая куча создаётся с ёмкостью, равной сумме размеров двух исходных куч.
2. **Копирование элементов:**
    - Элементы обеих куч добавляются в новую кучу с помощью функции `insert`. Это позволяет автоматически поддерживать свойства минимальной кучи.
3. **Исходные кучи остаются неизменными:**
    - Мы не изменяем содержимое массивов `heap1` и `heap2`.
#### Сравнение:

- **С разрушением:** Обе исходные кучи уничтожаются, их данные объединяются в новую кучу.
- **Без разрушения:** Исходные кучи остаются в памяти, данные копируются в новую кучу, что требует дополнительных операций вставки.

![[Pasted image 20241130031028.png]]

- Объединение массивов занимает O(n1+n2), где n1​ и n2​ — размеры исходных куч.
- Так как куча всегда состоит из нескольких слоев заполненных полностью и одного заполненного частично, и каждый следующий слой содержит в два раза больше вершин, чем предыдущий, то высота дерева будет log(n)
-  Вставка каждого элемента занимает O(log⁡k), где k — текущий размер новой кучи.
- Вставка всех n1+n2​ элементов требует: O((n1+n2)⋅log⁡(n1+n2)).


### <span style="color:rgb(197, 249, 154)">23. Приоритетные очереди. Левосторонняя приоритетная очередь, её реализация на базе структуры данных вида бинарное дерево. Операции вставки элемента, поиска минимума/максимума, удаления минимума/максимума, слияния с разрушением и без разрушения исходных левосторонних приоритетных очередей; их вычислительные сложности и реализация на языке C</span>

#### <span style="color:rgb(191, 138, 244)">Левосторонняя приоритетная очередь, её реализация на базе структуры данных вида бинарное дерево</span>

==Левосторонняя куча== (leftist heap) — двоичное левосторонее дерево, не обязательно сбалансированное, но с соблюдением порядка кучи.
##### Основные свойства левосторонней кучи:

1. **Свойство кучи:** Для каждого узла значение в нём меньше (или равно) значений в его дочерних узлах (для мин-кучи).
2. **Левостороннее свойство:** Для любого узла расстояние до ближайшего пустого узла в левом поддереве больше либо равно расстоянию в правом поддереве.

Расстояние до ближайшего пустого узла - ==null path length== или ==NPL==

![[Pasted image 20241205043413.png]]

#### <span style="color:rgb(191, 138, 244)">Структура узла</span>

```c
typedef struct Node {
    int key;
    int npl; // null path length
    struct Node *left;
    struct Node *right;
} Node;
```

#### <span style="color:rgb(191, 138, 244)">Создание нового узла</span>

```c
Node* createNode(int value) { 
	Node* newNode = (Node*)malloc(sizeof(Node)); 
	if (!newNode) return NULL;
	newNode->key = value; 
	newNode->left = newNode->right = NULL; 
	newNode->npl = 0; 
	return newNode; 
}
```

#### <span style="color:rgb(191, 138, 244)">Слияние с разрушением</span>

```c
Node* merge(Node* h1, Node* h2) {
    if (!h1) return h2;
    if (!h2) return h1;

    // Меняем местами кучи, чтобы минимальный ключ был в h1
    if (h1->key > h2->key) {
        Node* temp = h1;
        h1 = h2;
        h2 = temp;
    }

    // Рекурсивно сливаем правые поддеревья
    h1->right = merge(h1->right, h2);

    // Проверяем левостороннее свойство
    if (!h1->left || h1->left->npl < h1->right->npl) {
        Node* temp = h1->left;
        h1->left = h1->right;
        h1->right = temp;
    }

    // Обновляем NPL
    h1->npl = h1->right ? h1->right->npl + 1 : 0;
    return h1;
}
```

![[Pasted image 20241205043438.png]]
![[Pasted image 20241205043509.png]]
![[Pasted image 20241205043530.png]]
![[Pasted image 20241205043550.png]]

#### <span style="color:rgb(191, 138, 244)">Слияние без разрушения</span>

- Вместо того чтобы изменять указатели на поддеревья в исходных деревьях, мы будем создавать новые копии узлов для обеих куч.
- Рекурсивно копируем узлы, чтобы сохранить неизменными исходные кучи.

```c

// Функция для копирования узлов
Node* copyNode(Node* node) {
    if (node == NULL)
        return NULL;
    
    Node* newNode = createNode(node->key);
    newNode->npl = node->npl;
    newNode->left = copyNode(node->left);
    newNode->right = copyNode(node->right);
    return newNode;
}

// Функция для слияния двух левосторонних куч (без разрушения)
Node* mergeNonDestructive(Node* h1, Node* h2) {
    // Если одна из куч пуста, возвращаем копию другой
    if (h1 == NULL) return copyNode(h2);
    if (h2 == NULL) return copyNode(h1);

    // Копируем узлы, чтобы не разрушить исходные деревья
    Node* copyH1 = copyNode(h1);
    Node* copyH2 = copyNode(h2);

    // Убедимся, что минимальный ключ в копии h1
    if (copyH1->key > copyH2->key) {
        Node* temp = copyH1;
        copyH1 = copyH2;
        copyH2 = temp;
    }

    // Рекурсивно сливаем правые поддеревья
    copyH1->right = mergeNonDestructive(copyH1->right, copyH2);

    // Проверяем левостороннее свойство
    if (copyH1->left == NULL || copyH1->left->npl < copyH1->right->npl) {
        Node* temp = copyH1->left;
        copyH1->left = copyH1->right;
        copyH1->right = temp;
    }

    // Обновляем NPL
    copyH1->npl = copyH1->right ? copyH1->right->npl + 1 : 0;

    return copyH1;
}

```
#### <span style="color:rgb(191, 138, 244)">Вставка элемента</span>

Вставка выполняется через создание нового узла и его слияние с текущей кучей

```c
Node* insert(Node* root, int value) {
    Node* newNode = createNode(value);
    if (!newNode) return root;
    return merge(root, newNode);
}
```

![[Pasted image 20241205043052.png]]

#### <span style="color:rgb(191, 138, 244)">Поиск минимума</span>

Минимум — это значение в корне дерева.

```c
int findMin(Node* root, int* result) {
    if (!root) return -1;
    *result = root->key;
    return 0;
}
```

#### <span style="color:rgb(191, 138, 244)">Удаление минимума</span>

Минимальный элемент находится в корне. Его удаление сводится к слиянию его левого и правого поддерева.
```c
Node* deleteMin(Node* root) {
    if (!root) return NULL;
    Node* left = root->left;
    Node* right = root->right;
    free(root);
    return merge(left, right);
}
```


| Операция               | Лучшая сложность                        | Средняя сложность              | Худшая сложность               |
| ---------------------- | --------------------------------------- | ------------------------------ | ------------------------------ |
| Вставка элемента       | O(1)                                    | O(log n)                       | O(log n)                       |
| Слияние с разрушением  | O(log n)                                | O(log n)                       | O(log n)                       |
| Поиск минимума         | O(1)                                    | O(1)                           | O(1)                           |
| Поиск максимума        | O(log n)                                | O(log n)                       | O(log n)                       |
| Удаление минимума      | O(log n)                                | O(log n)                       | O(log n)                       |
| Удаление максимума     | O(log n)                                | O(log n)                       | O(log n)                       |
| Слияние без разрушения | O(log n), n - узлы в наибольшей очереди | O(n), n - узлы в двух очередях | O(n), n - узлы в двух очередях |

### <span style="color:rgb(197, 249, 154)">24. Приоритетные очереди. Косая приоритетная очередь, её реализация на базе структуры данных вида бинарное дерево. Операции вставки элемента, поиска минимума/максимума, удаления минимума/максимума, слияния с разрушением и без разрушения исходных косых приоритетных очередей; их вычислительные сложности и реализация на языке C</span>

==Косая приоритетная очередь (skew heap)== — это структура данных, которая реализует приоритетную очередь, используя бинарное дерево.
##### Свойства косой кучи:

1. **Свойство кучи (Heap Property):**  
    Значение любого узла меньше (или равно) значений в его дочерних узлах (для мин-кучи).
    
2. **Косое слияние (Skew Property):**  
    После каждой операции слияния поддеревья меняются местами. Это обеспечивает автоматическую балансировку.

#### <span style="color:rgb(191, 138, 244)">Структура узла</span>

```c
typedef struct Node {
    int key;              // Ключ (приоритет)
    struct Node* left;    // Левое поддерево
    struct Node* right;   // Правое поддерево
} Node;
```

#### <span style="color:rgb(191, 138, 244)">Создание нового узла</span>

```c
Node* createNode(int key) {
    Node* node = (Node*)malloc(sizeof(Node));
    if (!node) return NULL;
    node->key = key;
    node->left = NULL;
    node->right = NULL;
    return node;
}
```

#### <span style="color:rgb(191, 138, 244)">Слияние с разрушением</span>

Ключевая операция, которая используется для всех остальных
##### Алгоритм:
1. Сравниваем корни куч и выбираем и выбираем приоритетный
2. swap куч таким образом, чтобы слева оказалась приоритетная
3. Внутри левой кучи swap(left, right)
4. Продолжаем merge для левого поддерева левой кучи

```c

void swapNodes(Node** a, Node** b) {
    Node* temp = *a;
    *a = *b;
    *b = temp;
}

Node* merge(Node* h1, Node* h2)
    {
        // If one of the heaps is empty
        if (h1 == NULL)
            return h2;
        if (h2 == NULL)
            return h1;
 
        // Make sure that h1 has smaller
        // key.
        if (h1->key > h2->key)
           swap(&h1, &h2);
 
        // Swap h1->left and h1->right
        swap(&(h1->left), &(h1->right));
 
        // Merge h2 and h1->left and make
        // merged tree as left of h1.
        h1->left = merge(h1->left, h2);
 
        return h1;
    }
```

![[Pasted image 20241206151522.png]]
![[Pasted image 20241206151546.png]]

#### <span style="color:rgb(191, 138, 244)">Слияние без разрушения</span>

Мы не изменяем оригинальные структуры, а создаём новую очередь с элементами обеих исходных очередей. Это достигается копированием узлов вместо работы напрямую с указателями оригинальных деревьев.

```c

void swapNodes(Node** a, Node** b) {
    Node* temp = *a;
    *a = *b;
    *b = temp;
}

Node* copyNode(Node* node) {
    if (node == NULL)
        return NULL;

    Node* newNode = createNode(node->key);
    newNode->left = copyNode(node->left);
    newNode->right = copyNode(node->right);
    return newNode;
}

Node* merge(Node* h1, Node* h2){
    // Создаем копии исходных деревьев
    Node* copyH1 = copyNode(h1);
    Node* copyH2 = copyNode(h2);

    // Если одна из очередей пуста, возвращаем копию другой
    if (copyH1 == NULL)
        return copyH2;
    if (copyH2 == NULL)
        return copyH1;

    // Убедимся, что у copyH1 ключ меньше или равен copyH2
    if (copyH1->key > copyH2->key) {
        swap(&copyH1, &copyH2)
    }

    // Меняем местами левого и правого потомков copyH1
     swap(&(copyH1->left), &(copyH2->right));

    // Рекурсивно объединяем copyH2 с левым поддеревом copyH1
    copyH1->left = merge(copyH1->left, copyH2);

    return copyH1;
    }
```
#### <span style="color:rgb(191, 138, 244)">Поиск минимума</span>

Минимум — это значение в корне дерева.

```c
int findMin(Node* root, int* result) {
    if (!root) return -1;
    *result = root->key;
    return 0;
}
```

#### <span style="color:rgb(191, 138, 244)">Удаление минимума</span>

Минимальный элемент находится в корне. Его удаление сводится к слиянию его левого и правого поддерева.
```c
Node* deleteMin(Node* root) {
    if (!root) return NULL;
    Node* left = root->left;
    Node* right = root->right;
    free(root);
    return merge(left, right);
}
```


| Операция               | Лучшая сложность | Средняя сложность | Худшая сложность |
| ---------------------- | ---------------- | ----------------- | ---------------- |
| Вставка элемента       | O(1)             | O(log n)          | O(log n)         |
| Слияние с разрушениями | O(log n)         | O(log n)          | O(n)             |
| Поиск минимума         | O(1)             | O(n)              | O(n)             |
| Поиск максимума        | O(1)             | O(n)              | O(n)             |
| Удаление минимума      | O(log n)         | O(log n)          | O(n)             |
| Удаление максимума     | O(log n)         | O(log n)          | O(n)             |
| Слияние без разрушения | O(log n)         | O(log n)          | O(n)             |

### <span style="color:rgb(197, 249, 154)">25. Приоритетные очереди. Биномиальное дерево, ранг биномиального дерева, число элементов в биномиальном дереве заданного ранга. Биномиальная и фибоначчиева приоритетные очереди, их реализация на базе структур данных вида кольцевой список и дерево общего вида. Операции вставки элемента, поиска минимума/максимума, удаления минимума/максимума, слияния с разрушением и без разрушения исходных биномиальных/фибоначчиевых приоритетных очередей; их вычислительные сложности и реализация на языке C</span>

### Биномиальные деревья и очереди

==**Биномиальное дерево**== (Binomial Tree) — это упорядоченное дерево, которое определяется следующим образом:
1. Биномиальное дерево ранга `r` содержит `2^r` элементов.
2. Биномиальное дерево ранга `r` строится путём присоединения биномиального дерева ранга `r−1` к корню другого биномиального дерева ранга `r−1`.
#### Свойства биномиального дерева:
- Число элементов: `2^r`, где `r` — ранг.
- Высота дерева равна `r`.
- Число дочерних узлов корня в дереве ранга `r`: `r`.
#### Биномиальная очередь
==**Биномиальная очередь**== — это набор биномиальных деревьев, удовлетворяющих следующим условиям:
- Для каждого ранга `r` присутствует не более одного биномиального дерева.
- Деревья хранятся в виде упорядоченного списка, где деревья меньших рангов идут перед деревьями больших рангов.

#### <span style="color:rgb(191, 138, 244)">Структура</span>
```c
#include <stdio.h>
#include <stdlib.h>

typedef struct BinomialNode {
    int key;                        // Значение узла
    int degree;                     // Ранг (степень) дерева
    struct BinomialNode* parent;    // Родитель узла
    struct BinomialNode* child;     // Первый ребёнок
    struct BinomialNode* sibling;   // Следующий узел на том же уровне
} BinomialNode;

typedef struct BinomialHeap {
    BinomialNode* head;             // Указатель на голову списка деревьев
} BinomialHeap;
```
#### <span style="color:rgb(191, 138, 244)">Вставка узла</span>

**Обработка конфликтов деревьев с одинаковым рангом:**

- Просмотрите объединённый список деревьев:
    - Если встречаются два дерева с одинаковым рангом, объедините их в одно дерево:
        - Дерево с меньшим ключом становится корнем, а второе дерево — его поддеревом.
        - Увеличьте ранг результирующего дерева на 1.
    - Если встречаются три дерева одинакового ранга, оставьте одно для обработки на следующем шаге, а два других объедините.

```c
void insert(BinomialHeap* heap, int key) {
    BinomialHeap* tempHeap = (BinomialHeap*)malloc(sizeof(BinomialHeap));
    tempHeap->head = createNode(key);
    heap->head = unionHeaps(heap, tempHeap)->head;
    free(tempHeap);
}
```
#### <span style="color:rgb(191, 138, 244)">Поиск минимального</span>
```c
BinomialNode* findMin(BinomialHeap* heap) {
    BinomialNode* minNode = NULL;
    BinomialNode* current = heap->head;

    while (current) {
        if (!minNode || current->key < minNode->key) {
            minNode = current;
        }
        current = current->sibling;
    }
    return minNode;
}
```
#### <span style="color:rgb(191, 138, 244)">Удаление минимального</span>

#### Удаление минимального элемента:

- Удалите корень (узел с ключом −∞-\infty−∞) из кучи:
    1. Удалите корень минимального биномиального дерева.
    2. Разделите поддеревья удалённого дерева на отдельные биномиальные деревья.
    3. Переверните порядок поддеревьев (чтобы сохранить сортировку по рангу).
    4. Слейте оставшиеся биномиальные деревья с оставшейся кучей.

```c
void deleteMin(BinomialHeap* heap) {
    // Поиск минимального элемента
    BinomialNode* minPrev = NULL;
    BinomialNode* minNode = heap->head;
    BinomialNode* prev = NULL;
    BinomialNode* current = heap->head;

    while (current) {
        if (!minNode || current->key < minNode->key) {
            minNode = current;
            minPrev = prev;
        }
        prev = current;
        current = current->sibling;
    }

    // Удаление минимального элемента из списка
    if (minPrev) {
        minPrev->sibling = minNode->sibling;
    } else {
        heap->head = minNode->sibling;
    }

    // Создание новой кучи из детей удалённого узла
    BinomialNode* child = minNode->child;
    BinomialHeap* tempHeap = (BinomialHeap*)malloc(sizeof(BinomialHeap));
    tempHeap->head = NULL;

    while (child) {
        BinomialNode* next = child->sibling;
        child->sibling = tempHeap->head;
        tempHeap->head = child;
        child = next;
    }

    heap->head = unionHeaps(heap, tempHeap)->head;
    free(tempHeap);
    free(minNode);
}
```

#### <span style="color:rgb(191, 138, 244)">Поиск максимума</span>
```c
BinomialNode* findMax(BinomialHeap* heap) {
    BinomialNode* maxNode = NULL;
    int maxKey = INT_MIN;  // Используем минимальное значение как начальное

    BinomialNode* curr = heap->head;
    while (curr) {
        if (curr->key > maxKey) {
            maxKey = curr->key;
            maxNode = curr;
        }
        curr = curr->sibling;
    }
    return maxNode;
}
```
#### <span style="color:rgb(191, 138, 244)">Удаление максимального</span>
```c
void deleteMax(BinomialHeap* heap) {
    if (!heap->head) return;

    BinomialNode* maxPrev = NULL;
    BinomialNode* maxNode = heap->head;
    BinomialNode* prev = NULL;
    BinomialNode* curr = heap->head;

    int maxKey = INT_MIN;
    while (curr) {
        if (curr->key > maxKey) {
            maxKey = curr->key;
            maxNode = curr;
            maxPrev = prev;
        }
        prev = curr;
        curr = curr->sibling;
    }
    
    if (maxPrev) {
        maxPrev->sibling = maxNode->sibling;
    } else {
        heap->head = maxNode->sibling;
    }

    BinomialNode* child = maxNode->child;
    BinomialHeap* tempHeap = (BinomialHeap*)malloc(sizeof(BinomialHeap));
    tempHeap->head = NULL;

    while (child) {
        BinomialNode* nextChild = child->sibling;
        child->sibling = tempHeap->head;
        tempHeap->head = child;
        child = nextChild;
    }

    BinomialHeap* newHeap = unionHeaps(heap, tempHeap);
    heap->head = newHeap->head;

    free(maxNode);
    free(tempHeap);
}
```
#### <span style="color:rgb(191, 138, 244)">Слияние без разрушения</span>
```c
BinomialHeap* mergeHeaps(BinomialHeap* h1, BinomialHeap* h2) {
    BinomialHeap* newHeap = (BinomialHeap*)malloc(sizeof(BinomialHeap));
    newHeap->head = NULL;

    BinomialNode* t1 = h1->head;
    BinomialNode* t2 = h2->head;
    BinomialNode** pos = &(newHeap->head);

    while (t1 && t2) {
        if (t1->degree <= t2->degree) {
            *pos = t1;
            t1 = t1->sibling;
        } else {
            *pos = t2;
            t2 = t2->sibling;
        }
        pos = &((*pos)->sibling);
    }

    *pos = (t1) ? t1 : t2;
    return newHeap;
}
```
#### <span style="color:rgb(191, 138, 244)">Слияние c разрушения</span>
```c
BinomialHeap* unionHeaps(BinomialHeap* h1, BinomialHeap* h2) {
    BinomialHeap* mergedHeap = mergeHeaps(h1, h2);
    if (!mergedHeap->head) return mergedHeap;

    BinomialNode* prev = NULL;
    BinomialNode* curr = mergedHeap->head;
    BinomialNode* next = curr->sibling;

    while (next) {
        if (curr->degree != next->degree || 
            (next->sibling && next->sibling->degree == curr->degree)) {
            prev = curr;
            curr = next;
        } else {
            if (curr->key <= next->key) {
                curr->sibling = next->sibling;
                curr = mergeTrees(curr, next);
            } else {
                if (prev) {
                    prev->sibling = next;
                } else {
                    mergedHeap->head = next;
                }
                next = mergeTrees(next, curr);
                curr = next;
            }
        }
        next = curr->sibling;
    }
    return mergedHeap;
}
```

	
| Операция           | Лучший случай | Средний случай | Худший случай |
| ------------------ | ------------- | -------------- | ------------- |
| Вставка            | O(1)          | O(log n)       | O(log n)      |
| Поиск мин          | O(1)          | O(log n)       | O(log n)      |
| Поиск макс         | O(1)          | O(log n)       | O(log n)      |
| Удаление мин       | O(log n)      | O(log n)       | O(log n)      |
| Удаление макс      | O(log n)      | O(log n)       | O(log n)      |
| Слияние с разрущ   | O(log n)      | O(log n)       | O(log n)      |
| Слияние без разруш | O(log n)      | O(log n)       | O(log n)      |

### Фибоначчиевы очереди

==**Фибоначчиева очередь**== (Fibonacci Heap) — это структура данных, в которой операции выполняются быстрее за счёт ленивой обработки деревьев.
#### Основные свойства:
- Узлы организованы в виде деревьев общего вида.
- Хранится список корней деревьев в кольцевом списке.
- Поддерживается указатель на узел с минимальным значением.
#### <span style="color:rgb(191, 138, 244)">Структуры</span>
```c
typedef struct FibonacciNode {
    int key;
    struct FibonacciNode* parent;
    struct FibonacciNode* child;
    struct FibonacciNode* sibling;
    int degree;
    int mark;
} FibonacciNode;

typedef struct FibonacciQueue {
    FibonacciNode* min;
    int count;
} FibonacciQueue;
```
#### <span style="color:rgb(191, 138, 244)">Вставка</span>
```c
void insert(FibonacciQueue* queue, int key) {
    FibonacciNode* newNode = createNode(key);
    
    // Вставка нового узла в список корней
    if (queue->min == NULL) {
        queue->min = newNode;
    } else {
        newNode->sibling = queue->min;
        queue->min = newNode;
        if (newNode->key < queue->min->key) {
            queue->min = newNode;
        }
    }
    
    queue->count++;
}
```
#### <span style="color:rgb(191, 138, 244)">Поиск минимума</span>
```c
int findMin(FibonacciQueue* queue) {
    if (queue->min != NULL) {
        return queue->min->key;
    }
    return INT_MAX;
}
```
#### <span style="color:rgb(191, 138, 244)">Удаление минимума</span>
```c
void removeMin(FibonacciQueue* queue) {
    if (queue->min == NULL) return;
    
    FibonacciNode* minNode = queue->min;
    FibonacciNode* child = minNode->child;
    FibonacciNode* temp;

    // Дети минимального узла становятся корнями
    while (child != NULL) {
        temp = child->sibling;
        child->sibling = queue->min;
        queue->min = child;
        child->parent = NULL;
        child = temp;
    }

    // Удаляем минимальный элемент
    if (minNode->sibling == minNode) {
        queue->min = NULL;
    } else {
        queue->min = minNode->sibling;
    }

    // Консолидация деревьев
    consolidate(queue);
    queue->count--;
    free(minNode);
}
```

#### <span style="color:rgb(191, 138, 244)">Консолидация</span>
```c
void consolidate(FibonacciQueue* queue) {
    int maxDegree = (int)log2(queue->count) + 1;
    FibonacciNode* A[maxDegree];
    for (int i = 0; i < maxDegree; i++) A[i] = NULL;

    FibonacciNode* current = queue->min;
    FibonacciNode* next;
    
    while (current != NULL) {
        next = current->sibling;
        int degree = current->degree;

        // Слияние деревьев с одинаковыми степенями
        while (A[degree] != NULL) {
            if (A[degree]->key < current->key) {
                FibonacciNode* temp = current;
                current = A[degree];
                A[degree] = temp;
            }
            link(current, A[degree]);
            A[degree] = NULL;
            degree++;
        }
        
        A[degree] = current;
        current = next;
    }

    queue->min = NULL;
    for (int i = 0; i < maxDegree; i++) {
        if (A[i] != NULL) {
            A[i]->sibling = queue->min;
            queue->min = A[i];
            if (queue->min->key < A[i]->key) {
                queue->min = A[i];
            }
        }
    }
}
```
#### <span style="color:rgb(191, 138, 244)">Поиск максимума</span>
```c
int findMax(FibonacciQueue* queue) {
    if (queue->min == NULL) return INT_MIN;
    
    int max = INT_MIN;
    FibonacciNode* current = queue->min;

    do {
        if (current->key > max) {
            max = current->key;
        }
        current = current->sibling;
    } while (current != queue->min);

    return max;
}
```
#### <span style="color:rgb(191, 138, 244)">Удаление максимума</span>
```c
void removeMax(FibonacciQueue* queue) {
    if (queue->min == NULL) return;

    int maxValue = findMax(queue);
    FibonacciNode* maxNode = NULL;
    FibonacciNode* prev = NULL;
    FibonacciNode* current = queue->min;

    // Поиск максимального элемента
    do {
        if (current->key == maxValue) {
            maxNode = current;
            break;
        }
        prev = current;
        current = current->sibling;
    } while (current != queue->min);

    if (maxNode == NULL) return;

    // Удаляем максимальный элемент
    if (prev == NULL) {
        queue->min = maxNode->sibling;
    } else {
        prev->sibling = maxNode->sibling;
    }

    // Разделяем детей максимального узла и добавляем их как новые корни
    FibonacciNode* child = maxNode->child;
    while (child != NULL) {
        FibonacciNode* nextChild = child->sibling;
        child->sibling = queue->min;
        queue->min = child;
        child->parent = NULL;
        child = nextChild;
    }

    free(maxNode);

    // Консолидация после удаления
    consolidate(queue);
    queue->count--;
}
```
#### <span style="color:rgb(191, 138, 244)">Удаление элемента</span>
```c
void decreaseKey(FibonacciQueue* queue, FibonacciNode* node, int newKey) {
    if (newKey > node->key) {
        printf("Новый ключ не может быть больше текущего!\n");
        return;
    }

    node->key = newKey;
    FibonacciNode* parent = node->parent;

    // Перемещение вниз по дереву, пока не соблюдается инвариант Фибоначиевой очереди
    if (parent != NULL && node->key < parent->key) {
        cut(queue, node, parent);
        cascadingCut(queue, parent);
    }

    // Обновляем минимальный элемент, если это необходимо
    if (node->key < queue->min->key) {
        queue->min = node;
    }
}

void cut(FibonacciQueue* queue, FibonacciNode* node, FibonacciNode* parent) {
    if (parent->child == node) {
        parent->child = node->sibling;
    } else {
        FibonacciNode* sibling = parent->child;
        while (sibling->sibling != node) {
            sibling = sibling->sibling;
        }
        sibling->sibling = node->sibling;
    }

    parent->degree--;

    node->sibling = queue->min;
    node->parent = NULL;
    node->mark = 0;
    queue->min = node;
}

void cascadingCut(FibonacciQueue* queue, FibonacciNode* node) {
    FibonacciNode* parent = node->parent;
    if (parent != NULL) {
        if (node->mark == 0) {
            node->mark = 1;
        } else {
            cut(queue, node, parent);
            cascadingCut(queue, parent);
        }
    }
}

void removeElement(FibonacciQueue* queue, int key) {
    FibonacciNode* node = findNode(queue, key);
    if (node == NULL) {
        printf("Элемент не найден.\n");
        return;
    }

    decreaseKey(queue, node, INT_MIN);
    removeMin(queue);
}
```
#### <span style="color:rgb(191, 138, 244)">Слияние c разрушением</span>
```c
void mergeWithDestruction(FibonacciQueue* queue1, FibonacciQueue* queue2) {
    if (queue2->min == NULL) return;
    if (queue1->min == NULL) {
        queue1->min = queue2->min;
        queue1->count = queue2->count;
        return;
    }

    // Объединяем корни очереди
    FibonacciNode* temp = queue1->min;
    while (temp->sibling != NULL) {
        temp = temp->sibling;
    }
    temp->sibling = queue2->min;

    // Обновляем минимальный элемент
    if (queue2->min->key < queue1->min->key) {
        queue1->min = queue2->min;
    }

    queue1->count += queue2->count;
    
    // Освобождаем память для queue2
    queue2->min = NULL;
    queue2->count = 0;

    // Консолидация после слияния
    consolidate(queue1);
}
```
#### <span style="color:rgb(191, 138, 244)">Слияние без разрушения</span>
```c
FibonacciQueue* mergeWithoutDestruction(FibonacciQueue* queue1, FibonacciQueue* queue2) {
    FibonacciQueue* newQueue = createQueue();

    if (queue1->min != NULL) {
        // Объединяем корни обеих очередей
        FibonacciNode* temp = queue1->min;
        while (temp->sibling != NULL) {
            temp = temp->sibling;
        }
        temp->sibling = queue2->min;

        newQueue->min = queue1->min;
        newQueue->count = queue1->count + queue2->count;
        
        // Обновляем минимальный элемент
        if (queue2->min != NULL && queue2->min->key < queue1->min->key) {
            newQueue->min = queue2->min;
        }

        // Консолидация
        consolidate(newQueue);
    } else {
        // Если queue1 пуста, просто копируем queue2
        newQueue->min = queue2->min;
        newQueue->count = queue2->count;
    }

    return newQueue;
}
```


| Операция           | Лучший случай | Средний случай | Худший случай |
| ------------------ | ------------- | -------------- | ------------- |
| Вставка            | O(1)          | O(1)           | O(1)          |
| Поиск мин          | O(1)          | O(1)           | O(1)          |
| Поиск макс         | O(1)          | O(log n)       | O(n)          |
| Удаление мин       | O(log n)      | O(log n)       | O(log n)      |
| Удаление макс      | O(log n)      | O(log n)       | O(n)          |
| Слияние с разрущ   | O(log n)      | O(log n)       | O(log n)      |
| Слияние без разруш | O(log n)      | O(log n)       | O(log n)      |
| Удаление элемента  | O(log n)      | O(log n)       | O(log n)      |


### <span style="color:rgb(197, 249, 154)">26. Отношение эквивалентности на пространстве элементов. Кастомизация операции отношения эквивалентности для заданного контекста в языке C. Алгоритм дихотомического поиска, его алгоритмическая сложность</span>

#### <span style="color:rgb(191, 138, 244)">Кастомизация операции отношения эквивалентности для заданного контекста в языке C</span>

Кастомизация операции отношения эквивалентности в языке C — это процесс определения собственного способа проверки эквивалентности двух элементов, который зависит от требований задачи или особенностей данных. Это особенно полезно, если стандартная операция сравнения (например, `==`) не подходит.
То есть необходимо создать свою отдельную функцию для проверки эквивалентности вместо использования операторов. 
#### Пример:

1. <span style="color:rgb(124, 238, 219)">Эквивалентность по модулю</span>
	В этом случае два числа считаются эквивалентными, если их остатки от деления на фиксированное число n совпадают. Это удобно, например, при группировке чисел по категориям.
```c
int isEquivalentModulo(int a, int b, int n) {
    return (a % n) == (b % n);
}

if (isEquivalentModulo(15, 20, 5)) {
    printf("15 и 20 эквивалентны по модулю 5.\n");
}
```

2. <span style="color:rgb(124, 238, 219)">Эквивалентность структур данных</span>
	Иногда нужно сравнивать сложные структуры (например, двумерные точки, прямоугольники или пользовательские типы). Для этого пишется отдельная функция, учитывающая все поля структуры.
```c
#include <stdio.h>

typedef struct {
    int x;
    int y;
} Point;

int isPointsEqual(Point p1, Point p2) {
    return (p1.x == p2.x) && (p1.y == p2.y);
}

int main() {
    Point a = {2, 3};
    Point b = {2, 3};

    if (isPointsEqual(a, b)) {
        printf("Точки эквивалентны.\n");
    } else {
        printf("Точки не эквивалентны.\n");
    }
}
```

#### <span style="color:rgb(191, 138, 244)">Алгоритм дихотомического поиска, его алгоритмическая сложность</span>

Дихотомический (или бинарный) поиск применяется для поиска элемента в отсортированном массиве. Алгоритм работает следующим образом:

1. Находим средний элемент массива.
2. Если значение искомого элемента совпадает со средним, поиск завершён.
3. Если искомый элемент меньше среднего, продолжаем поиск в левой половине массива.
4. Если искомый элемент больше среднего, продолжаем поиск в правой половине массива.
5. Повторяем процесс, пока не будет найден элемент или массив не станет пустым.
```c
#include <stdio.h>

int binarySearch(int arr[], int size, int target) {
    int left = 0, right = size - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (arr[mid] == target) {
            return mid; // Элемент найден
        }
        if (arr[mid] < target) {
            left = mid + 1; // Поиск в правой половине
        } else {
            right = mid - 1; // Поиск в левой половине
        }
    }
    return -1; // Элемент не найден
}

int main() {
    int arr[] = {1, 3, 5, 7, 9, 11};
    int size = sizeof(arr) / sizeof(arr[0]);
    int target = 7;

    int result = binarySearch(arr, size, target);
    if (result != -1) {
        printf("Элемент %d найден на индексе %d\n", target, result);
    } else {
        printf("Элемент %d не найден\n", target);
    }
}
```

- Алгоритмическая сложность O(logn), где n — количество элементов в массиве. Это связано с тем, что на каждом шаге массив делится на две части

### <span style="color:rgb(197, 249, 154)">27. Дерево скобочного выражения. Вычисление арифметических выражений с помощью деревьев. Алгоритм конвертации строкового представления арифметического выражения, записанного в инфиксной форме, в дерево арифметического выражения. Алгоритм вычисления значения арифметического выражения по его дереву</span>

#### <span style="color:rgb(191, 138, 244)">Дерево скобочного выражения</span>

==Дерево выражений== – это древовидная структура данных, которая нужна для бесскобочного представления арифметических выражений. В реализации обычно используется бинарное дерево. В дереве выражений `скобки == поддеревья`, которые указывают на группировку операций и операндов, чтобы определить порядок их выполнения.

Рассмотрим выражение:  
`(3 + 5) × (2 - 4)`

```c
        ×
      /   \
    +       -
   / \     / \
  3   5   2   4
```
##### Компоненты дерева выражений:
1. **Корень** — верхний узел дерева, представляющий основную операцию (в данном примере умножение `×`).
2. **Внутренние узлы** — узлы, представляющие операции (например, `+`, `-`).
3. **Листья** — узлы, содержащие значения или переменные (например, `3`, `5`, `2`, `4`).
#### <span style="color:rgb(191, 138, 244)">Алгоритм конвертации строкового представления арифметического выражения, записанного в инфиксной форме, в дерево арифметического выражения</span>

#### Алгоритм

- 2 стека: операнды(аргументы), операции(действия)
- вход: строка-формула (обрабатываем формулу слева направо)
- если текущий символ - буква, то создаётся узел дерева, в который помещается этот аргумент, ссылки на левые и правые поддеревья являются пустыми
- указатель на созданный узел дерева заносится в стек операндов
- если текущий символ - открывающая скобка, то заносим её в стек операций
- если текущий символ - знак операции, если стек операции не пуст, если приоритет текущей операции большее приоритета текущей операций на стеке, то заносим её на вершину стека
- иначе (приоритет текущей операции не больше) формируем узел дерева в поле data которого помещается знак текущей операции, указатель на правое поддерево - это элемент вершины стека операндов, указатель на левое поддерево - следующий элемент вершины стека операндов
- обработанные операнды удаляются из стека, а в стек операндов помещается указатель на созданный узел
- эти действия повторять до тех пор, пока приоритет текущей операции не станет больше приоритета операции на вершине стека операций или стек не опустеет, знак текущей операции - в стек
- если текущий символ - символ закрывающей скобки, то создаём узел дерева, в поле данные которого помещаем знак операцию с вершины стека операций, указатели на правые, левые поддеревья этого узла - элементы с вершины стека операций
- обработанные аргументы стека удаляются, указатель на созданный узел помещается в стек операндов, повторять этот шаг до тех пор, пока на вершине стека операций не окажется открывающей скобки
- если достигли конца формулы, если стек операций не пуст, то формируем узел дерева, в поле  data помещаем знак операции, указатели на левые, правые поддеревья - указатели с вершины стека операндов, указатель на созданный узел помещаем в стек операндов
#### Вспомогательные функции

```c
// Узел дерева
typedef struct Node {
    char data;              // символ (операнд или оператор)
    struct Node *left;      // левое поддерево
    struct Node *right;     // правое поддерево
} Node;

// Стек для хранения указателей на узлы дерева
typedef struct Stack {
    Node* nodes[100]; // массив указателей на узлы дерева
    int top;          // индекс вершины стека
} Stack;

// Функции для работы со стеком
Stack* createStack() {
    Stack* stack = (Stack*)malloc(sizeof(Stack));
    stack->top = -1;
    return stack;
}

void push(Stack* stack, Node* node) {
    stack->nodes[++stack->top] = node;
}

Node* pop(Stack* stack) {
    if (stack->top == -1) return NULL;
    return stack->nodes[stack->top--];
}

Node* peek(Stack* stack) {
    if (stack->top == -1) return NULL;
    return stack->nodes[stack->top];
}

int isEmpty(Stack* stack) {
    return stack->top == -1;
}

// Проверка, является ли символ оператором
int isOperator(char c) {
    return c == '+' || c == '-' || c == '*' || c == '/';
}

// Возвращает приоритет операции
int getPriority(char op) {
    if (op == '+' || op == '-') return 1;
    if (op == '*' || op == '/') return 2;
    return 0;
}

// Создание нового узла дерева
Node* createNode(char data) {
    Node* node = (Node*)malloc(sizeof(Node));
    node->data = data;
    node->left = node->right = NULL;
    return node;
}
```

#### Реализация рабочего (нет) алгоритма

```c
// Построение дерева из инфиксного выражения
Node* buildExpressionTree(char* expression) {
    Stack* operands = createStack();  // Стек для операндов
    Stack* operators = createStack(); // Стек для операторов

    for (int i = 0; expression[i] != '\0'; i++) {
        char current = expression[i];

        if (isalpha(current)) {
            // Если символ - буква, создаем узел и помещаем в стек операндов
            Node* node = createNode(current);
            push(operands, node);
        } else if (current == '(') {
            // Если символ - открывающая скобка, помещаем её в стек операторов
            push(operators, createNode(current));
        } else if (isOperator(current)) {
            // Если символ - оператор
            while (!isEmpty(operators) && 
                   getPriority(current) <= getPriority(peek(operators)->data)) {
                // Формируем узел дерева
                Node* operatorNode = pop(operators);
                operatorNode->right = pop(operands);
                operatorNode->left = pop(operands);
                push(operands, operatorNode);
            }
            // Помещаем текущий оператор в стек операторов
            push(operators, createNode(current));
        } else if (current == ')') {
            // Если символ - закрывающая скобка
            while (!isEmpty(operators) && peek(operators)->data != '(') {
                Node* operatorNode = pop(operators);
                operatorNode->right = pop(operands);
                operatorNode->left = pop(operands);
                push(operands, operatorNode);
            }
            // Удаляем открывающую скобку
            pop(operators);
        }
    }

    // Завершаем обработку оставшихся операторов
    while (!isEmpty(operators)) {
        Node* operatorNode = pop(operators);
        operatorNode->right = pop(operands);
        operatorNode->left = pop(operands);
        push(operands, operatorNode);
    }

    // Корень дерева - единственный элемент в стеке операндов
    Node* root = pop(operands);

    // Освобождаем память, выделенную под стеки
    free(operands);
    free(operators);

    return root;
}
```

#### <span style="color:rgb(191, 138, 244)">Алгоритм вычисления значения арифметического выражения по его дереву</span>

#### Алгоритм :

1. **Понимание структуры дерева:**
    - Каждый узел дерева содержит:
        - **Операнд** (число или переменная) в листьях дерева.
        - **Оператор** в промежуточных узлах.
    - Листья дерева — это конечные значения.
    - Промежуточные узлы определяют операцию, которую нужно выполнить над поддеревьями.
2. **Алгоритм (рекурсивный обход дерева):**
    - Начинаем обход дерева с корневого узла.
    - Для каждого узла:
        1. Если узел — **лист (операнд)**, возвращаем значение узла.
        2. Если узел — **оператор**:
            - Рекурсивно вычисляем значение левого поддерева.
            - Рекурсивно вычисляем значение правого поддерева.
            - Применяем оператор текущего узла к значениям, полученным из левого и правого поддеревьев.
            - Возвращаем результат вычисления.
3. **Детали вычисления:**
    - Для оператора в текущем узле выполняем соответствующую операцию:
        - `+` — сложение.
        - `-` — вычитание.
        - `*` — умножение.
        - `/` — деление (проверяем деление на ноль).
4. **Завершение работы:**
    - После завершения рекурсии результат вычисления будет находиться в корне дерева.

```c
// Узел дерева
typedef struct Node {
    char data;              // символ (операнд или оператор)
    struct Node *left;      // левое поддерево
    struct Node *right;     // правое поддерево
} Node;

// Рекурсивная функция для вычисления значения дерева с обработкой ошибок
double evaluate(Node* root, int* errorCode) {
    if (!root) {
        *errorCode = -1; // Ошибка: пустой узел
        return 0;
    }

    // Если узел - лист (операнд)
    if (!root->left && !root->right) {
        if (isdigit(root->data)) {
            return root->data - '0'; // Преобразование символа в число
        } else {
            *errorCode = -2; // Ошибка: неизвестный операнд
            return -2;
        }
    }

    // Рекурсивно вычисляем левое и правое поддеревья
    double leftValue = evaluate(root->left, errorCode);
    if (*errorCode) return -3; // Прекращаем выполнение при ошибке

    double rightValue = evaluate(root->right, errorCode);
    if (*errorCode) return -3; // Прекращаем выполнение при ошибке

    // Выполняем операцию текущего узла
    switch (root->data) {
        case '+': return leftValue + rightValue;
        case '-': return leftValue - rightValue;
        case '*': return leftValue * rightValue;
        case '/':
            if (rightValue == 0) {
                *errorCode = -4; // Ошибка: деление на ноль
                return -4;
            }
            return leftValue / rightValue;
        default:
            *errorCode = -5; // Ошибка: неизвестный оператор
            return -5;
    }
}
```

```c
       *
      / \
     +   2
    / \
   3   5
```
```c
Результат: 16.00
```

### <span style="color:rgb(197, 249, 154)">28. Хеш-функция и хеш-таблица. Свойства хеш-функций. Понятие коллизии. Метод цепочек разрешения коллизий. Операции добавления/удаления элемента по ключу, поиска элемента для хеш-таблицы, их вычислительные сложности и реализация на языке C</span>

#### <span style="color:rgb(191, 138, 244)">Хеш-функция и хеш-таблица</span>

==Хеш-функция== – это функция, преобразующая входные данные (ключ) в число фиксированного диапазона, называемое **хеш-значением**. Хеш-функции используются для ускорения поиска данных, проверки целостности и других задач.

==Хеш-таблица== –  это структура данных, которая позволяет эффективно хранить, добавлять и искать данные по ключу. Она сочетает в себе массив для быстрого доступа и хеш-функцию для преобразования ключей в **хеш-значения**.

#### <span style="color:rgb(191, 138, 244)">Свойства хеш-функций</span>

- **Детерминированность**: Для одного и того же входа хеш-функция всегда возвращает одинаковое значение.
- **Распределенность**: Хеш-значения должны быть равномерно распределены по всем возможным корзинам, чтобы минимизировать количество коллизий.
- **Быстродействие**: Хеш-функция должна вычисляться быстро.
- **Минимизация коллизий**: Хеш-функция должна минимизировать вероятность возникновения коллизий, при которых разные ключи имеют одно и то же хеш-значение.

#### <span style="color:rgb(191, 138, 244)">Понятие коллизии</span>

==Коллизия== – это ситуация, когда два различных ключа преобразуются в одинаковое хеш-значение. Например, если хеш-таблица имеет 10 ячеек, а хеш-функция возвращает значение 3 для двух разных ключей.

#### <span style="color:rgb(191, 138, 244)">Метод цепочек разрешения коллизий</span>

Каждая ячейка таблицы содержит указатель на связанный список, в который помещаются элементы с одинаковым хеш-значением. Таким образом, если несколько ключей попадают в одну ячейку (из-за одинакового хеш-значения), они хранятся в связанном списке.
#### Пример

```c
индекс = хеш(ключ) % размер_таблицы
```

```c
индекс = 3 % 5 = 3
```

Добавим ключи `"apple"`, `"orange"`, `"banana"` при размере таблицы 5:

- `хеш("apple") = 3`
- `хеш("orange") = 3` (коллизия с `"apple"`)
- `хеш("banana") = 1`

Таблица будет выглядеть так:

```c
Индекс | Список
0      | -
1      | "banana"
2      | -
3      | "apple" -> "orange"
4      | -
```

#### <span style="color:rgb(191, 138, 244)">Структура узла списка и хеш-таблицы</span>

```c
// Элемент списка (узел)
typedef struct Node {
    char *key; // ключ
    int value; //данные, связанные с ключом
    struct Node *next; // указательна следующий элемент списка
} Node;

// Хеш-таблица
typedef struct HashTable {
    Node **buckets;  // указатель на массив указателей на узлы
    int size; // размер таблицы
} HashTable;
```

#### <span style="color:rgb(191, 138, 244)">Создание узла</span>

```c
Node* create_node(const char* key, int value) {
    Node* new_node = (Node*)malloc(sizeof(Node));
    if (!new_node) {
        return NULL;
    }
    new_node->key = strdup(key); // Копируем строку ключа в выделенную память
    new_node->value = value;    // Устанавливаем значение
    new_node->next = NULL;      // Изначально узел не связан с другими
    return new_node;
}
```

- Сложность - О(1)
#### <span style="color:rgb(191, 138, 244)">Хеш-функция</span>

```c
unsigned int hash_function(const char *key, int size) {
    unsigned int hash = 0;
    while (*key) {
        hash = (hash * 31 + *key++) % size;
    }
    return hash;
}
```

#### <span style="color:rgb(191, 138, 244)">Создание таблицы</span>

```c
HashTable *create_table(int size) {
    HashTable *table = malloc(sizeof(HashTable));
    if (!table) return NULL;
    table->buckets = (Node**)malloc(size * sizeof(Node*));
    if (!table->buckets) {
        free(table);
        return NULL;
    }
    table->size = size;
    for (int i = 0; i < size; i++) { 
	    table->buckets[i] = NULL; // Изначально все ячейки пусты 
	}
    return table;
}
```

- Сложность - О(n)
#### <span style="color:rgb(191, 138, 244)">Добавление элемента по ключу</span>

```c
int insert(HashTable* table, const char* key, int value) {
    unsigned int index = hash_function(key, table->size); // Вычисляем индекс
    Node* new_node = create_node(key, value);            // Создаём новый узел
    if (!new_node) return -1;
    
    if (!table->buckets[index]) {
        // Если ячейка пустая, помещаем новый узел
        table->buckets[index] = new_node;
    } else {
        // Если коллизия, добавляем в начало списка
        new_node->next = table->buckets[index];
        table->buckets[index] = new_node;
    }
    return 0;
}
```

- Сложность - О(1), O(n) в худшем случае (при высокой плотности коллизий (все элементы попадают в одну корзину)).
#### <span style="color:rgb(191, 138, 244)">Удаление элемента по ключу</span>

```c
int delete(HashTable* table, const char* key) {
    unsigned int index = hash_function(key, table->size); // Вычисляем индекс
    Node* current = table->buckets[index];
    Node* prev = NULL;

    while (current) {
        if (strcmp(current->key, key) == 0) {  // Найден элемент
            if (prev) {
                prev->next = current->next;   // Удаляем из середины списка
            } else {
                table->buckets[index] = current->next;   // Удаляем первый узел
            }
            free(current->key);                          // Освобождаем память
            free(current);                               // Удаляем узел
            return 0;
        }
        prev = current;
        current = current->next;                  // Переход к следующему узлу
    }
    return -1;
}
```

- Сложность - О(1), O(n) в худшем случае (если коллизии ведут к длинным спискам в корзинах).
#### <span style="color:rgb(191, 138, 244)">Поиск элемента по ключу</span>

```c
Node* search(HashTable* table, const char* key) {
    unsigned int index = hash_function(key, table->size); // Вычисляем индекс
    Node* current = table->buckets[index];               // Ищем в списке корзины

    while (current) {
        if (strcmp(current->key, key) == 0) {            // Сравниваем ключи
            return current;                              // Найденный элемент
        }
        current = current->next;                     // Переход к следующему узлу
    }
    return NULL; // Элемент не найден
}
```

- Сложность - О(1), O(n) в худшем случае (если коллизии ведут к длинным спискам в корзинах).
#### <span style="color:rgb(191, 138, 244)">Удаление таблицы</span>

```c
void destroy_table(HashTable* table) {
    if (!table) return; // Проверка: таблица уже уничтожена

    // Проходим по всем корзинам
    for (int i = 0; i < table->size; i++) {
        Node* current = table->buckets[i];
        while (current) {
            Node* next = current->next; // Сохраняем указатель на следующий узел
            free(current->key);        // Освобождаем память для ключа
            free(current);             // Освобождаем память для узла
            current = next;            // Переходим к следующему узлу
        }
    }

    // Освобождаем память для массива корзин и самой таблицы
    free(table->buckets);
    free(table);
}
```

- Сложность - О(n + k), где n - число ячеек, k - число узлов в таблице

### <span style="color:rgb(197, 249, 154)">29. Язык программирования C++. Понятия класса и объекта. Поля и методы классов</span>

==Класс== — это пользовательский тип данных, который представляет собой шаблон или описание для создания объектов. Класс определяет, какие данные (поля) и функции (методы) будут доступны у созданных объектов.
#### Структура класса:

1. **Поля** — это переменные, которые хранят данные объекта.
2. **Методы** — это функции, которые описывают поведение объектов класса.
3. **Модификаторы доступа** — определяют уровень доступа к полям и методам:
    - `public` — открытый доступ (доступен извне).
    - `private` — закрытый доступ (только внутри класса).
    - `protected` — защищённый доступ (для наследников и самого класса).
    По умолчанию все элементы, определённые в классе, являются закрытыми. Это означает, что к ним могут получить доступ только другие члены класса, никакие другие части программы этого сделать не могут.
#### Общий формат объявления класса 

```c++
class имя_класса {
private:
	закрытые данные и функции
public:
	 открытые данные и функции
};
```
==Объект== — это экземпляр класса, то есть конкретная реализация класса с определённым набором значений полей.
#### Пример класса:

```c++
#include <iostream> 
#include <string> 
using namespace std;

class Car { 
private: 
	string brand; 
	string model; 
	int year; 
	int mileage;
public: 
	Car(string b, string m, int y, double mi);
	void displayInfo() const;
	int get_year() const;
};
```

#### Основные принципы ООП в C++:

1. ==Инкапсуляция== — это принцип объектно-ориентированного программирования, при котором данные (поля) и функции (методы), работающие с этими данными, объединяются в одну сущность — **класс**. Инкапсуляция позволяет скрыть внутреннюю реализацию класса и защищать данные от некорректного использования извне.

2. ==Наследование== — это механизм ООП, который позволяет одному классу (наследнику) унаследовать свойства и методы другого класса (родителя).

3. ==Полиморфизм== — это свойство объектов вести себя по-разному в зависимости от их типа. Полиморфизм достигается за счёт переопределения методов в наследниках и использования указателей или ссылок на базовый класс для работы с объектами.

![[Pasted image 20241124130352.png]]


### <span style="color:rgb(197, 249, 154)">30. Конструкторы, деструкторы. Конструктор со списком инициализации. Ключевое слово explicit. Ключевое слово const (применительно к методам класса), особенности. Ключевое слово this</span>

#### <span style="color:rgb(237, 125, 164)">Конструкторы и деструкторы</span>

==Конструктор== — это специальный метод класса, который автоматически вызывается при создании объекта. Конструктор инициализирует объект при его создании.  Обычно конструктор используется, чтобы придать переменным экземпляра, определённым в классе, начальные значения или выполнить исходные действия, необходимые для создания полностью сформированного объекта (например, динамическое выделение памяти).

**Основные свойства:**
- Имя конструктора совпадает с именем класса.
- Не имеет возвращаемого значения.
- Может быть перегружен (несколько конструкторов с разными параметрами).

==Деструктор== — это метод, который вызывается при уничтожении объекта для освобождения ресурсов (например, памяти или файлов).

**Основные свойства:**
- Имя деструктора — это имя класса с символом `~` перед ним.
- Не принимает параметров и не возвращает значения.
- Автоматически вызывается при завершении времени жизни объекта.

>В общем случае уничтожение объекта происходит, когда он покидает область видимости. Это актуально для **локальных объектов**, которые создаются в стеке функции. Когда выполнение программы выходит за пределы блока, в котором объект был создан, автоматически вызывается его **деструктор**, и память, занимаемая объектом, освобождается.

#### Особенности уничтожения объектов

1. **Для объектов в стеке:**
    - Объекты, созданные локально (без использования оператора `new`), уничтожаются автоматически, как только они покидают свою область видимости.
    - Деструктор вызывается один раз для каждого объекта.
    
2. **Для объектов в куче:**
    - Если объект создается с помощью `new`, он размещается в **куче** (heap) и его уничтожение необходимо выполнять вручную с помощью `delete`.
    - Если объект в куче не удаляется явно, происходит **утечка памяти**.
#### Исключения

1. **Статические объекты**:  
    Объекты, объявленные как `static`, уничтожаются только один раз, при завершении программы (даже если они покидают область видимости).
    
2. **Объекты, передаваемые по ссылке или указателю**:  
	Если объект передается по ссылке или указателю, он не уничтожается автоматически при выходе из функции, поскольку деструктор вызовется только для объекта, которому принадлежит память.

```c++
class Resource {
public:
    Resource() {
        cout << "Resource acquired.\n";
    }
    ~Resource() {
        cout << "Resource released.\n";
    }
};

int main() {
    Resource res; // Конструктор вызывается при создании объекта
    return 0;     // Деструктор вызывается при выходе из области видимости
}
```

```c++
Resource acquired.
Resource released.
```

#### <span style="color:rgb(237, 125, 164)">Конструктор со списком инициализации</span>

Список инициализации позволяет инициализировать поля объекта **до выполнения тела конструктора**, что особенно важно для:

- Константных полей (`const`).
- Ссылок (`&`).

Конструктору можно передавать аргументы. Конструктор может при необходимости иметь список инициализаторов элементов. Список инициализаторов элементов используется в конструкторе класса для явной инициализации членов класса до выполнения тела конструктора. Этот список инициализаторов элементов предоставляет способ инициализировать члены класса сразу при создании объекта.

```c++
ClassName(параметры) : поле1(значение1), поле2(значение2), ... {
    // Тело конструктора
}
```

```c++
class Person {
private:
    const string name;
    int age;
public:
    Person(string n, int a) : name(n), age(a) {}

    void display() const {
        cout << "Name: " << name << ", Age: " << age << endl;
    }
};
```

- Позволяет повысить производительность (инициализация происходит прямо в момент создания объекта, без вызова конструктора по умолчанию и последующего присваивания).
- Обязателен для `const` и ссылочных полей, иначе компилятор выдаст ошибку.

#### <span style="color:rgb(237, 125, 164)">Ключевое слово explicit</span>

Это ключевое слово ставится перед объявлением конструктора с одним параметром (или с большим числом параметров, но когда все параметры, начиная со второго, имеют значения по умолчанию) и предотвращает неявное преобразование типов при инициализации.

```c++
class Person {
public:
    Person(int age) {
        cout << "Person created with age: " << age << endl;
    }
};

int main() {
    Person p = 25; // Неявное преобразование int в Person
    return 0;
}
```

```c++
class Person {
public:
    explicit Person(int age) {
        cout << "Person created with age: " << age << endl;
    }
};

int main() {
    // Person p = 25; // Ошибка компиляции
    Person p(25);    // Явный вызов конструктора
    return 0;
}
```

- то есть используется когда необходимо запретить неявное преобразование типов, чтобы избежать потенциальных ошибок
#### <span style="color:rgb(237, 125, 164)">Ключевое слово const</span>

Ключевое слово `const`, примененное к методу класса, говорит компилятору, что метод **не изменяет** состояние объекта.

Объявление функции-члена с помощью ключевого const слова указывает, что функция является функцией "только для чтения", которая не изменяет объект, для которого она вызывается.

Константная функция-член не может изменять нестатические элементы данных или вызывать функции-члены, которые не являются константами. Чтобы объявить функцию-член константной, поместите ключевое слово `const` после закрывающей круглых скобок списка аргументов. Ключевое слово`const` является обязательным как в объявлении, так и в определении.

```c++
class Person {
private:
    string name;
public:
    Person(string n) : name(n) {}

    void display() const {
        cout << "Name: " << name << endl;
    }

    void setName(string n) {
        name = n;
    }
};

int main() {
    const Person p("Alice");
    p.display(); // Разрешено
    // p.setName("Bob"); // Ошибка: вызов неконстантного метода для константного объекта
    return 0;
}
```

#### <span style="color:rgb(237, 125, 164)">Ключевое слово this</span>

Ключевое слово `this` в языке программирования C++ представляет указатель на текущий объект данного класса. Таким образом, через `this` мы сможем обратиться внутри класса к любым членам этого класса.

**Основные использования:**
1. Для разрешения конфликтов имен (если имя поля и параметра совпадают)
2. Для возврата ссылки на текущий объект

```c++
class Person { 
public: 
	Person& setName(string name) { 
		this->name = name; 
		return *this; 
	}
private: 
	string name; 
};
```

![[Pasted image 20241124181403.png]]

### <span style="color:rgb(197, 249, 154)">31. Язык программирования C++. Инициализация и присваивание. Конструктор копирования. Оператор присваивания. Деструктор. Конструктор перемещения</span>

#### <span style="color:rgb(191, 138, 244)">Инициализация и присваивание</span>

##### 1. Инициализация объекта класса

Инициализация происходит в момент создания объекта. Для этого используются:
- Конструкторы (по умолчанию, с параметрами, копирования, перемещения).
- Список инициализации членов.

```c++
class MyClass {
    int a;
    int b;

public:
    // Конструктор с параметрами
    MyClass(int x, int y) : a(x), b(y) {} // Инициализация через список членов

    void print() const {
        std::cout << "a: " << a << ", b: " << b << std::endl;
    }
};

int main() {
    MyClass obj1(10, 20); // Инициализация через вызов конструктора
    obj1.print();         // Вывод: a: 10, b: 20
}
```

##### 2. Присваивание объекта класса

Присваивание происходит после создания объекта, когда один объект копирует (или перемещает) данные из другого с помощью **оператора присваивания (`operator=`)**.

```c++
class MyClass {
    int a;

public:
    // Конструктор
    MyClass(int x) : a(x) {}

    // Оператор присваивания
    MyClass& operator=(const MyClass& other) {
        if (this != &other) { // Проверка самоприсваивания
            a = other.a;
        }
        return *this;
    }

    void print() const {
        std::cout << "a: " << a << std::endl;
    }
};

int main() {
    MyClass obj1(10);  // Инициализация
    MyClass obj2(20);  // Инициализация

    obj2 = obj1;       // Присваивание
    obj2.print();      // Вывод: a: 10
}
```

![[Pasted image 20241125233743.png]]

#### <span style="color:rgb(191, 138, 244)">Конструктор копирования</span>

==Конструктор копирования== - это специальный метод класса, который создает новый объект на основе уже существующего объекта. Он копирует значения всех членов класса из одного объекта в другой. Вызов конструктора копирования происходит при инициализации объекта другим объектом. Если он не определён явно, компилятор создаёт его автоматически (т.н. "по умолчанию"), выполняя побитовую копию. Если копирующий конструктор определён, то он принимает в качестве формального параметра ссылку на объект класса (с квалификатором `const`).

>[!Note]
>Конструктор копирования - замечательная вещь, когда нам надо создать один объект на основе другого, однако данный конструктор имеет свои недостатки. Например, если поле представляет указатель, то копируется адрес. В итоге поля обоих объектов будут указывать на один и тот же адрес в памяти. Соответственно если мы захотим изменить значение для одного объекта, это значение также изменится и для другого объекта. И в этом случае мы можем определить свой конструктор копирования.

```c++
class MyClass {
    int value;

public:
    MyClass(int v) : value(v) {} // Обычный конструктор

    // Конструктор копирования
    MyClass(const MyClass& other) {
        value = other.value;
    }

    void print() const {
        std::cout << "Value: " << value << std::endl;
    }
};

int main() {
    MyClass obj1(10);
    MyClass obj2 = obj1; // Вызов конструктора копирования
    obj2.print(); // Выведет: Value: 10
}
```

#### <span style="color:rgb(191, 138, 244)">Оператор присваивания</span>

Оператор присваивания (`operator=`) используется для копирования данных из одного уже существующего объекта в другой. Если он не определён явно, компилятор предоставляет **реализацию по умолчанию**, выполняющую побитовую копию.

```c++
class MyClass {
    int value;

public:
    MyClass(int v) : value(v) {}

    // Оператор присваивания
    MyClass& operator=(const MyClass& other) {
        if (this == &other) return *this; // Проверка самоприсваивания
        value = other.value;
        return *this;
    }

    void print() const {
        std::cout << "Value: " << value << std::endl;
    }
};

int main() {
    MyClass obj1(10);
    MyClass obj2(20);

    obj2 = obj1; // Вызов оператора присваивания
    obj2.print(); // Выведет: Value: 10
}
```

#### <span style="color:rgb(191, 138, 244)">Деструктор</span>

==Деструктор== — это метод, который вызывается при уничтожении объекта для освобождения ресурсов (например, памяти или файлов).

**Основные свойства:**
- Имя деструктора — это имя класса с символом `~` перед ним.
- Не принимает параметров и не возвращает значения.
- Автоматически вызывается при завершении времени жизни объекта.

>В общем случае уничтожение объекта происходит, когда он покидает область видимости. Это актуально для **локальных объектов**, которые создаются в стеке функции. Когда выполнение программы выходит за пределы блока, в котором объект был создан, автоматически вызывается его **деструктор**, и память, занимаемая объектом, освобождается.

#### Особенности уничтожения объектов

1. **Для объектов в стеке:**
    - Объекты, созданные локально (без использования оператора `new`), уничтожаются автоматически, как только они покидают свою область видимости.
    - Деструктор вызывается один раз для каждого объекта.
    
2. **Для объектов в куче:**
    - Если объект создается с помощью `new`, он размещается в **куче** (heap) и его уничтожение необходимо выполнять вручную с помощью `delete`.
    - Если объект в куче не удаляется явно, происходит **утечка памяти**.
#### Исключения

1. **Статические объекты**:  
    Объекты, объявленные как `static`, уничтожаются только один раз, при завершении программы (даже если они покидают область видимости).
    
2. **Объекты, передаваемые по ссылке или указателю**:  
	Если объект передается по ссылке или указателю, он не уничтожается автоматически при выходе из функции, поскольку деструктор вызовется только для объекта, которому принадлежит память.

```c++
class Resource {
public:
    Resource() {
        cout << "Resource acquired.\n";
    }
    ~Resource() {
        cout << "Resource released.\n";
    }
};

int main() {
    Resource res; // Конструктор вызывается при создании объекта
    return 0;     // Деструктор вызывается при выходе из области видимости
}
```

```c++
Resource acquired.
Resource released.
```

#### <span style="color:rgb(191, 138, 244)">Конструктор перемещения</span>

==Конструктор перемещения== - это специальный метод класса, который перемещает ресурсы из одного объекта в другой, без их копирования.

```c++
class my_class{
public:
	my_class(my_class&& other) noexcept{ 
		// конструктор перемещения
	} 
};
```

```c++
class MyClass {
    int* ptr;

public:
    MyClass(int v) : ptr(new int(v)) {}

    // Конструктор перемещения
    MyClass(MyClass&& other) noexcept : ptr(other.ptr) {
        other.ptr = nullptr; // Обнуляем указатель у перемещённого объекта
    }

    ~MyClass() {
        delete ptr;
    }

    void print() const {
        if (ptr)
            std::cout << "Value: " << *ptr << std::endl;
        else
            std::cout << "Object is empty" << std::endl;
    }
};

int main() {
    MyClass obj1(10);
    MyClass obj2 = std::move(obj1); // Вызов конструктора перемещения

    obj2.print(); // Выведет: Value: 10
    obj1.print(); // Выведет: Object is empty
}
```

>[!Tip]
>Оператор перемещения (`operator=`) аналогичен конструктору перемещения, но применяется к уже существующему объекту.




### <span style="color:rgb(197, 249, 154)">32. Инкапсуляция в языке программирования C++. Модификаторы доступа public, private, protected, назначение</span>

==Инкапсуляция== — это принцип объектно-ориентированного программирования, при котором данные (поля) и функции (методы), работающие с этими данными, объединяются в одну сущность — **класс**. Инкапсуляция позволяет скрыть внутреннюю реализацию класса и защищать данные от некорректного использования извне

#### Цели инкапсуляции:

1. **Скрытие реализации**:
    - Реализация класса скрывается от пользователя, предоставляя только необходимый интерфейс.
2. **Контроль доступа**:
    - Ограничивается возможность несанкционированного изменения или неправильного использования данных.
3. **Упрощение интерфейса**:
    - Внешний код взаимодействует только с методами и не зависит от внутренней структуры класса.

#### Модификаторы доступа

В C++ для управления доступом к полям и методам класса используются три модификатора доступа:

1. **`public` <span style="color:rgb(107, 199, 230)">(публичный доступ):</span>
    - Члены класса, объявленные как `public`, доступны из любой части программы.
    - Обычно это интерфейс, с которым взаимодействует внешний код.
2. **`private` <span style="color:rgb(107, 199, 230)">(приватный доступ):</span>
    - Доступен только внутри самого класса.
    - Поля и методы, объявленные как `private`, не видны извне.
    - Используется для скрытия деталей реализации и защиты данных.
3. **`protected` <span style="color:rgb(107, 199, 230)">(защищённый доступ):</span>
    - Доступен только внутри самого класса и классов-наследников.
    - Обычно используется в случае наследования, когда нужно разрешить наследникам доступ к полям и методам, но скрыть их от внешнего кода.
#### Назначение модификаторов доступа

Модификаторы доступа используются для управления доступом к членам класса (полям и методам). Они определяют, какие части программы могут использовать или изменять данные, что помогает организовать структуру кода и обеспечить безопасность данных.

![[Pasted image 20241124142733.png]]
#### Пример:

```c++
#include <iostream>
#include <string>
using namespace std;

class Employee {
private: // Приватные члены — недоступны извне
    string name;
    double salary;

public: // Публичные методы — интерфейс класса
    // Конструктор
    Employee(string n, double s) {
        name = n;
        salary = s > 0 ? s : 0; // Проверка корректности
    }

    // Геттер для имени
    string getName() const {
        return name;
    }

    // Сеттер для зарплаты
    void setSalary(double s) {
        if (s > 0) {
            salary = s;
        } else {
            cout << "Invalid salary amount!" << endl;
        }
    }

    // Геттер для зарплаты
    double getSalary() const {
        return salary;
    }

protected: // Защищённый метод
    void displayInfo() const {
        cout << "Name: " << name << ", Salary: " << salary << endl;
    }
};

class Manager : public Employee {
public:
    Manager(string n, double s) : Employee(n, s) {}

    // Публичный метод для отображения информации
    void showDetails() {
        displayInfo(); // Доступ к защищённому методу базового класса
    }
};

int main() {
    Employee emp("Alice", 5000);
    cout << "Employee: " << emp.getName() << ", Salary: " << emp.getSalary() << endl;

    emp.setSalary(6000); // Изменение зарплаты через публичный метод
    cout << "Updated Salary: " << emp.getSalary() << endl;

    Manager mgr("Bob", 8000);
    mgr.showDetails(); // Отображение информации через наследника

    return 0;
}
```

#### <span style="color:rgb(197, 249, 154)">33. Наследование в языке программирования C++. Наследование вида «быть», наследование вида «иметь». Модификаторы public, private, protected при наследовании, назначение и особенности</span>

#### Наследование

==Наследование== - это процесс, посредством которого один объект может приобретать свойства другого. Точнее, объект может наследовать основные свойства другого объекта и добавлять к ним черты, характерные только для него. Наследование позволяет поддерживать иерархию классов. 
Механизм наследования позволяет одному классу (наследнику) унаследовать свойства и методы другого класса (родителя).

>Класс, который наследуется, называется *базовым*. Класс, который наследует базовый класс, называется *производным*.

Общий формат объявления класса, который наследует базовый класс, имеет следующий вид:

```c++
class имя_производного класса: доступ имя_базового класса {
	// тело производного класса
};
```

```c++
class first {
	// ...
}

class second : public first{
	//...
}
```
#### Модификаторы public, private, protected при наследовании, назначение и особенности

Если один класс наследует другой, члены базового класса становятся членами производного. Однако статус доступа членов базового класса в производном классе определяется спецификатором доступа, используемым для наследования базового класса. Спецификатор доступа базового класса выражается одним из ключевых слов: `public`, `private`, `protected`.
#### <span style="color:rgb(124, 238, 219)">1) public</span>

Если базовый класс наследуется как `public-класс`, все его `public-члены` становятся `public-членами` производного класса. Во всех случаях `private-члены` базового класса остаются закрытыми в рамках этого класса и недоступны для членов производного.

![[Pasted image 20241124152730.png]]
![[Pasted image 20241124152805.png]]

#### <span style="color:rgb(124, 238, 219)">2) private</span>

Если базовый класс наследуется как `private-класс`, все его `public-члены` становятся `private-членами` производного класса. Это означает, что они доступны для членов производного класса, но недоступны для других частей программы.

![[Pasted image 20241124153928.png]]

#### <span style="color:rgb(124, 238, 219)">3) protected</span>

Защищённым (`protected`) является член, который открыт для своей иерархии классов, но закрыт вне этой иерархии. 

![[Pasted image 20241124154521.png]]

> [!Tip]
> ![[Pasted image 20241124154728.png]]


![[Pasted image 20241124154851.png]]
![[Pasted image 20241124154918.png]]

**Что происходит с членами базового класса?**

- **`public`** члены базового класса становятся **`protected`** в производном классе.
- **`protected`** члены базового класса остаются **`protected`**.
- **`private`** члены базового класса остаются недоступными (их доступ возможен только через методы базового класса, если такие есть).

```c
class Base {
public:
    int publicVar;
protected:
    int protectedVar;
private:
    int privateVar;
};

class Derived : protected Base {
public:
    void accessMembers() {
        publicVar = 1;     // Доступно как protected
        protectedVar = 2;  // Доступно как protected
        // privateVar = 3;  // Ошибка: private-члены недоступны
    }
};
```

#### Наследование вида «быть», наследование вида «иметь»

#### <span style="color:rgb(124, 238, 219)">Наследование вида «быть» (is-a)</span>

Это классический тип наследования, где производный класс представляет собой разновидность базового класса. Основная идея заключается в том, что производный класс наследует все свойства и методы базового класса, которые он может использовать, а также может добавлять собственные уникальные свойства и методы.
###### Когда использовать наследование вида "быть"
- Когда между базовым и производным классом есть четкая связь типа "является".
- Когда необходимо обеспечить единый интерфейс для работы с базовым и производным классами.
- Когда требуется переопределение поведения базового класса в производных.

```c
#include <iostream>
#include <string>
using namespace std;

class Animal {
public:
    string name;

    Animal(string n){name = n;}

    void eat() {
        cout << name << " is eating.\n";
    }

    virtual void makeSound() {
        cout << name << " makes a sound.\n";
    }
};

class Dog : public Animal {
public:
    Dog(string n) : Animal(n) {}

    void makeSound() override {
        cout << name << " barks.\n";
    }

    void fetch() {
        cout << name << " is fetching the ball.\n";
    }
};

int main() {
    Dog dog("Buddy");
    dog.eat();       // унаследовано от Animal
    dog.makeSound(); // переопределено в Dog
    dog.fetch();     // метод Dog

    return 0;
}
```

#### <span style="color:rgb(124, 238, 219)">Наследование вида «иметь» (has-a)</span>

Наследование вида «иметь» — это не прямое наследование, а использование одного класса внутри другого в качестве свойства. Этот подход известен как **композиция** или **агрегация**, и он позволяет одному классу "иметь" другие классы в своей структуре.
###### Когда используется:
- Один класс включает другой в качестве своего члена (атрибута).
- Включаемый класс создается и управляется содержащим классом.
- Подходит, если один объект **явно зависит** от другого.
```c
class Engine {
public:
    void start() {
        std::cout << "Engine started\n";
    }
};

class Car {
private:
    Engine engine; // Car "имеет" Engine
public:
    void startCar() {
        engine.start(); // Используем метод Engine
        std::cout << "Car is running\n";
    }
};

int main() {
    Car myCar;
    myCar.startCar();
    return 0;
}
```
